'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/','title':"Docs",'section':"Home",'content':"  Documents     "});index.add({'id':1,'href':'/docs/documents/projects/','title':"Projects",'section':"Documents",'content':"Projects #     hU-Go-Girl   HUGO (feat Github)를 이용한 정적 웹페이지 생성   "});index.add({'id':2,'href':'/docs/documents/projects/hugogirl/','title':"hU-Go-Girl",'section':"Projects",'content':"hU-Go-Girl #   관련 내용 및 참고 링크\n Static Web page Hugo Jekyll Github Markdown Buy me a coffee   -- Static vs Dynamic #  정적웹은 사용자의 요청에 대해 준비된 응답만을 제공.\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph LR A[ 사용자 ]--|요청|B[웹서버] B--|응답|A style A fill:#ffffff,stroke:#000000,stroke-width:1px style B fill:#ffffff,stroke:#000000,stroke-width:1px 동적웹은 사용자의 요청을 위해 추가적인 가공을 거쳐 처리.\ngraph LR D[ 사용자 ]--|요청|F[웹서버]--|프로세싱|G[(DB서버)] G--|응답|F--|응답|D style D fill:#ffffff,stroke:#000000,stroke-width:1px style F fill:#ffffff,stroke:#000000,stroke-width:1px style G fill:#ffffff,stroke:#000000,stroke-width:1px 개인 기록 용도로는 동적 서비스가 불필요. 해당 사이트는 정적웹으로 선택.\nGithub #  Git은 리눅스 커널의 소스코드 관리를 위해 리누스 토발즈1가 개발. Git을 위한 무료 저장소 Github. 해당 서비스에는 자료 공유를 위한 Markdown 지원의 웹 호스팅 서비스도 포함.\n Github 가입 Repository 생성 Github Page 설정 Add a README file 포함 Setting \u0026gt; Github Pages \u0026gt; Source 설정  Jekyll vs Hugo #  Jekyll은 Github의 창립자2가 Ruby3라는 언어로 만든 정적 웹 생성기. 별도 빌드 없이 Github와 연동 가능. Hugo는 GO로 작성된 정적 웹 생성기. 유사한 툴로 중국에서 제작된 Hexo도 있음.4 둘다 빠른 빌드를 특징으로 하고 있음.\nJekyll은 테마가 많고 Github에 빌드 없이 연동할 수 있음. 다만 컨텐츠에 따라 빌드 시간이 비례하여 증가5.\nTheme #  문서와 기록이 주 용도로 텍스트 기반의 테마를 검토. Jekyll에서는 Just-the-doc. Hugo에서는 Book 테마. 필요에 따라 몇가지 디자인을 수정.\nMarkdown #  Markdown은 HTML과 같은 마크업 언어임. 마크업 언어는 별도 표현을 위한 기술언어를 의미.\nMarkdown 정리\nBuy Me a Coffee #  개인 컨텐츠 제작자를 위한 후원 서비스 사이트. Buy me a coffee 가입 중 Paypal에 등록하여 방문객이 1$~5$ 소액 송금이 가능.6 커피 아이콘을 커스터마이징하여 사용.\nConclusion #   VSC에서 Markdown을 이용 포스트를 작성 Hugo Build / Sever를 통해 로컬에서 확인 Hugo Public를 통해 Public 빌드 Git을 통해 Github에 Push하고 Web으로 Publish  # 1) Hugo Build 경로를 삭제합니다. rm -rf ./public/ # 2) Hugo Build 합니다. hugo -t book # 3) 전 제 github를 Hugo build 경로 안에 위치 시켰습니다. 해당내용을 .git만 제외하고 삭제하는 내용입니다. find ./youraccount.github.io/ -maxdepth 1 ! -name \u0026#34;.git\u0026#34; ! -name \u0026#34;youraccount.github.io\u0026#34; -exec rm -rf {} \\; # 4) public을 pull한 경로로 옮깁니다. cp -r ./public/* ./youraccount.github.io/ # 5) pull한 경로로 이동합니다. cd ./youraccount.github.io # 6) add / commit / push 합니다. git add . git commit -m \u0026#34;$(date +\u0026#34;%y%m%d_%H:%M\u0026#34;)\u0026#34; git push origin master \nReference #   생활코딩 : 버전관리 시스템 생활코딩 : Github  Footnote #    저명하신 키보드 워리어 \u0026#x21a9;\u0026#xfe0e;\n 톰 프레스톤 워너 \u0026#x21a9;\u0026#xfe0e;\n 일본산 \u0026#x21a9;\u0026#xfe0e;\n 비교자료 \u0026#x21a9;\u0026#xfe0e;\n [Jekyll성능이슈]](https://forestry.io/blog/how-i-reduced-my-jekyll-build-time-by-61/) \u0026#x21a9;\u0026#xfe0e;\n 한국 PayPal FAQs \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':3,'href':'/docs/documents/frontend/','title':"Front End",'section':"Documents",'content':"Front End #     Markdown   Markdown 문법 설명   "});index.add({'id':4,'href':'/docs/documents/frontend/markdown/','title':"Markdown",'section':"Front End",'content':"Markdown #   Markdown은 HTML 변환이 가능한 텍스트 기반 경량 마크업 언어. 특수 기호와 문자를 이용해 쉽게 쓰고 읽을 수 있으며 문법이 비교적 쉽고 간단한 것이 특징.\nHeader #  Markdown # H1 크기 제목입니다. ## H2 크기 제목입니다. ### H3 크기 제목입니다. #### H4 크기 제목입니다. ##### H5 크기 제목입니다. ###### H6 크기 제목입니다. Result H1 크기 제목입니다. H2 크기 제목입니다. H3 크기 제목입니다. H4 크기 제목입니다. H5 크기 제목입니다. H6 크기 제목입니다.  Emphasis #  Markdown *강조 형태 1* _강조 형태 2_ **강조 형태 3** __강조 형태 4__ ~~강조 형태 5~~ Result 강조 형태 1\n강조 형태 2\n강조 형태 3\n강조 형태 4\n강조 형태 5 List #  Markdown 1. 순서 리스트 1 2. 순서 리스트 2 3. 순서 리스트 3 - 리스트 1 - 리스트 2 - 리스트 3 - 리스트 1 - 리스트 1-1 - 리스트 1-1-1 - 리스트 2 - 리스트 2-1 - 리스트 2-1-1 - 리스트 3 - 리스트 3-1 - 리스트 3-1-1 Result  순서 리스트 1 순서 리스트 2 순서 리스트 3   리스트 1 리스트 2 리스트 3 리스트 1  리스트 1-1  리스트 1-1-1     리스트 2  리스트 2-1  리스트 2-1-1     리스트 3  리스트 3-1  리스트 3-1-1       Blockquotes #  Markdown \u0026gt; 인용 1 \u0026gt; 인용 2 \u0026gt; 인용 3 \u0026gt; 인용 1 \u0026gt;\u0026gt; 인용 2 \u0026gt;\u0026gt;\u0026gt; 인용 3 탭) 인용 1 탭) 인용 2 탭) 인용 3 Result  인용 1\n인용 2\n인용 3 인용 1\n 인용 2\u0026gt;\n 인용 3 탭) 인용 1 탭) 인용 2 탭) 인용 3\n    Inline code #  Markdown ```Rust fn main () { println!(\u0026#34;Hello World!\u0026#34;); } ``` \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; { fn main () { println!(\u0026#34;Hello World!\u0026#34;); } } \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; Result fn main () { println!(\u0026#34;Hello World!\u0026#34;); }  { fn main () { println!(\"Hello World!\"); } }   Tables #  Markdown | Header1 | Header2 | Header3 | Header4 | Header5 | | :------ | ------: | :-----: | ------- | ------- | | a | b | c | **d** | ~~e~~ | | f | g | h | i | j | | k | l | m | n | o | Result    Header1 Header2 Header3 Header4 Header5     a b c d e   f g h i j   k l m n o     Checkbox #  Markdown 1. [ ] To-Do 1 2. [x] To-Do 2 - [ ] To-Do 3 - [x] To-Do 4 Result  To-Do 1 To-Do 2   To-Do 3 To-Do 4   Hyperlinks #  Markdown [Prokoptasis](https://prokoptasis.github.io/docs/documents/frontend/markdown/) Result Prokoptasis Images #  Markdown ![coffee](../../../../../coffee.jpg) [![coffee](../../../../../coffee.jpg)](https://prokoptasis.github.io/docs/documents/frontend/markdown/) Result  Iframe #  Markdown \u0026lt;iframe width=\u0026#34;100%\u0026#34; height=\u0026#34;400px\u0026#34; src=\u0026#34;https://www.youtube.com/embed/4Vs25c7dzTQ\u0026#34; frameborder=\u0026#34;0\u0026#34; allow=\u0026#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen\u0026gt;\u0026lt;/iframe\u0026gt; Result   Etc #  Markdown 라인1 *** 라인2 --- 라인3 ___ 라인4 \u0026lt;hr\u0026gt; 문장 1 \u0026lt;br\u0026gt; 문장 2 (공백3칸) 문장 3 (공백없음) 문장 4 \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;가운데 정렬\u0026lt;/div\u0026gt; \u0026lt;span style=\u0026#34;color:red\u0026#34;\u0026gt;빨\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#0055FF\u0026#34;\u0026gt;파\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:rgb(21, 250, 16)\u0026#34;\u0026gt;녹\u0026lt;/span\u0026gt; Result 라인1\n 라인2\n 라인3\n 라인4\n 문장 1 문장 2 (공백3칸) 문장 3 (공백없음) 문장 4 가운데 정렬 빨 파 녹  Footnotes #  각주[^1] 각주1\n  각주입니다. \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':5,'href':'/docs/documents/backend/','title':"Back End",'section':"Documents",'content':"Back End #     Rust   Rust Language Study   Go   Go Language Study   SQL   SQL 문법 설명   "});index.add({'id':6,'href':'/docs/documents/backend/rust/','title':"Rust",'section':"Back End",'content':"RUST #     Rust Basic   The Rust Programming Language   Rust Basic 02   Rust Basic 02   "});index.add({'id':7,'href':'/docs/documents/backend/go/','title':"Go",'section':"Back End",'content':"GO #     GO Basic   예제로 배우는 GO 프로그리밍 : GO 기초   GO Advanced   Nomadcoders - 쉽고 빠른 Go 시작하기   "});index.add({'id':8,'href':'/docs/documents/backend/sql/','title':"SQL",'section':"Back End",'content':"SQL #     SQL Basic   SQL 기본 교육 자료   SQL Basic 2   SQL Basic Query 2   "});index.add({'id':9,'href':'/docs/documents/backend/sql/sql01/','title':"SQL Basic",'section':"SQL",'content':"SQL BASIC 기본 교육 자료 #   SQL은 Sturctured Query Langugage의 약자로 데이터베이스의 데이터를 관리하기 위해 사용하는 언어. 자료의 검색과 관리, 스키마의 생성과 수정, 객체의 접근 조정 및 관리의 기능 제공. ANSI SQL 기본 문법은 원래 어떤 데이터베이스와도 호환이 가능해야 하나 통상 Vendor들이 표준을 잘지키지않는 편이라 기본적인 수준에서만 호환이 가능. NoSQL 계열의 데이터베이스에서는 사용되지 않음. (다음은 오라클 기준임)\nLive SQL #   Oracle 가입 Oracle Live SQL 접속 \u0026ldquo;Start Coding Now\u0026rdquo; Live SQL 실행  Hello World! #  select \u0026#39;Hello World!\u0026#39; from dual; DDL / DML / DCL #  조회를 위한 예제 테이블이 작성을 위해 DDL, DML, DCL 개념 필요.\n ddl (data definition language) ...  데이터 정의 언어로 데이터베이스에 오브젝트를 생성,삭제,변경 및 제거하는 명령문\ncreate : 데이터베이스에 오브젝트를 생성 drop : 데이터베이스에 오브젝트를 삭제 alter : 데이터베이스에 오브젝트를 변경 truncate : 테이블에서 데이터를 삭제\n    dml (data manipulation languge) ...  데디터 조작 언어로 데이터베이스 테이블에서 데이터를 질의,생성,수정 및 삭제하는 질의문\nselect : 테이블에서 데이터를 검색 insert : 테이블에 데이터를 생성 update : 테이블에서 데이터를 변경 delete : 데이블에서 데이터를 삭제\n    dcl (data control language) ...  데이터 제어 언어로 데이터베이스의 권한을 관리하는데 사용하는 명령문\ngrant : 데이터베이스 사용자에게 특정 권한을 부여 revoke : 데이터베이스 사용자에게 특정 권한을 제거\n   Table Creation #   table creation ...  create table my_table_1 ( column_1 varchar2(10), column_2 number, column_3 date ) ; insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;홍길동\u0026#39;,23,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;김철수\u0026#39;,19,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;이영희\u0026#39;,32,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;박민호\u0026#39;,22,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;김종철\u0026#39;,45,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;김철수\u0026#39;,36,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;신영신\u0026#39;,32,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;최철호\u0026#39;,11,sysdate);     데이터 생성 결과를 조회\nquery select * from my_table_1 ; result    COLUMN_1 COLUMN_2 COLUMN_3     홍길동 23 10-OCT-20   김철수 19 10-OCT-20   이영희 32 10-OCT-20   박민호 22 10-OCT-20   김종철 45 10-OCT-20   김철수 36 10-OCT-20   신영신 32 10-OCT-20   최철민 11 10-OCT-20    Download CSV 8 rows selected. Select / From #   select / from ...  -- 주석입니다. select * from my_table_1; -- 컬럼명을 지정합니다. select column_1,column_3 from my_table_1;     Where / And #   where / and ...  -- where select * from my_table_1 where column_2 = 32; -- where / 부등호 1 select * from my_table_1 where column_2 \u0026lt;= 30; -- where / 부등호 2 select * from my_table_1 where column_2 \u0026gt;= 30; -- where / 부등호 3 select * from my_table_1 where column_2 \u0026gt; 30; -- where / 부등호 4 select * from my_table_1 where column_2 \u0026lt; 30; -- where / and select * from my_table_1 where column_2 \u0026gt; 10 and column_2 \u0026lt; 40; -- where / and / 문자열 1 select * from my_table_1 where column_1 = \u0026#39;홍길동\u0026#39; and column 2 = 23; -- where / and / 문자열 2 select * from my_table_1 where column_1 != \u0026#39;홍길동\u0026#39;; -- where / and / 문자열 3 select * from my_table_1 where column_1 \u0026lt;\u0026gt; \u0026#39;홍길동\u0026#39;; -- where / and / 문자열 / like 1 select * from my_table_1 where column_1 like \u0026#39;김%\u0026#39;; -- where / and / 문자열 / like 2 select * from my_table_1 where column_1 like \u0026#39;%철%\u0026#39;; -- where / and / 문자열 / like 3 select * from my_table_1 where column_1 like \u0026#39;%철\u0026#39;; -- where / and / 문자열 / like 4 select * from my_table_1 where column_1 like \u0026#39;김%철\u0026#39;; -- where / and / 문자열 / like 5 select * from my_table_1 where column_1 not like \u0026#39;%철\u0026#39;; -- where / and / between select * from my_table_1 where column_2 between 22 and 32; -- where / and / in select * from my_table_1 where column_1 in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;); -- where / and / not in select * from my_table_1 where column_1 not in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;); -- where / and / in / or select * from my_table_1 where column_1 in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;) or column_2 = 22; -- where / and / or / and 1 select * from my_table_1 where column_1 in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;) or column_2 = 22 and column_1 like \u0026#39;%수\u0026#39;; -- where / and / or / and 2 select * from my_table_1 where (column_1 in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;) or column_2 = 22) and column_1 like \u0026#39;%수\u0026#39;;     dual / + - * / #   dual / operatios ...  -- dual / + - * / select 2+3, 5-2, 2*3, 8/2 from dual; -- mod, power, sign, cos, tan select mod(7,3),power(2,3),sign(1),cos(1),tan(1) from dual; -- number, text, null, number+null, date select 1, \u0026#39;TEXT\u0026#39;, null, 10+2+null, sysdate from dual; -- number+null = null select 10+2+null from dual; -- number+text(number) = number select 10+2+\u0026#39;3\u0026#39; from dual; -- number+text : error select 10+2+\u0026#39;A\u0026#39; from dual; -- lower/upper select \u0026#39;Case\u0026#39;,lower(\u0026#39;Case\u0026#39;),upper(\u0026#39;Case\u0026#39;) from dual;     count / ditinct / alias / lower / upper #   count / ditinct / alias / lower / upper ...  -- count select count(*) from my_table_1; -- distinct select distinct column_1 from my_table_1; -- distinct / count select count(distinct column_1),count(column_1) from my_table_1; -- distinct / count / alias select count(distinct column_1) col1,count(column_1) col2,count(tab.column_1) col3 from my_table_1 tab;     from / nested from / with as #   from / nested from / with as ...  -- from 1 select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ; -- nested from select * from ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ) ; -- with 1 with tab_1 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ) select * from tab_1 ; -- with 2 with tab_1 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ) , tab_2 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30 ) select * from tab_2 ; -- with 3 with tab_1 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ) , tab_2 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30 ) select * from ( select * from tab_2 where column_1 like \u0026#39;%철%\u0026#39; ) ;     union all / union / intersect / minus #   union all / union / intersect / minus ...  -- union all with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 union all select * from tab_2 ; -- union with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 union all select * from tab_2 ; -- intersect with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 intersect select * from tab_2 ; -- minus with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 intersect select * from tab_2 ;     join 1 / join 2 / join 3 / join 4 / join 5 #   join ...  -- join 1 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a, tab_2 b where a.column_1 = b.column_1 ; -- join 2 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a, tab_2 b where a.column_1 = b.column_1 and a.column_2 = b.column_2 ; -- join 3 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a, tab_2 b where a.column_1 = b.column_1 (+) and a.column_2 = b.column_2 (+) ; -- join 4 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a, tab_2 b where a.column_1 (+) = b.column_1 and a.column_2 (+) = b.column_2 ; -- join 5 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a full outer join tab_2 b on ( a.column_1 = b.column_1 and a.column_2 = b.column_2 ) ;     substr / length / replace / decode / instr / lpad / rapd / reg_exp #   substr / length / replace / decode / instr / lpad / rapd / reg_exp  ...  select column_1, substr(column_1,1,1) \u0026#34;성2\u0026#34;, substr(column_1,2) \u0026#34;이름1\u0026#34;, substr(column_1,2,2) \u0026#34;이름2\u0026#34;, substr(column_1,-2) \u0026#34;이름3\u0026#34;, length(column_1) \u0026#34;길이\u0026#34;, replace(column_1,\u0026#39;길동\u0026#39;,\u0026#39;길수\u0026#39;) \u0026#34;교체\u0026#34;, decode(column_1,\u0026#39;이영희\u0026#39;,\u0026#39;요주의\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;악플러\u0026#39;,\u0026#39;김종철\u0026#39;,\u0026#39;유부남\u0026#39;,\u0026#39;-\u0026#39;) \u0026#34;디코드\u0026#34;, instr(column_1,\u0026#39;철\u0026#39;) \u0026#34;찾기1\u0026#34;, instr(column_1,\u0026#39;신\u0026#39;,1) \u0026#34;찾기2\u0026#34;, instr(column_1,\u0026#39;신\u0026#39;,2) \u0026#34;찾기3\u0026#34;, column_1, lpad(column_2,3,\u0026#39;0\u0026#39;) \u0026#34;채우기1\u0026#34;, rpad(column_2,3,\u0026#39;0\u0026#39;) \u0026#34;채우기2\u0026#34;, substr(column_1,1,1)||\u0026#39;씨_\u0026#39;||column_2||\u0026#39;세\u0026#39; \u0026#34;잇기\u0026#34;, regexp_substr(column_1,\u0026#39;[^철]+\u0026#39;,1,1) \u0026#34;정규식찾기1\u0026#34; from my_table_1 ;     nvl / trim #   nvl / trim ...  with data_list as ( select \u0026#39; data1 \u0026#39; col1 from dual union all select \u0026#39;data2 \u0026#39; col1 from dual union all select \u0026#39; data3\u0026#39; col1 from dual union all select \u0026#39; \u0026#39; col1 from dual union all select null col1 from dual ) select col1, length(col1) col1_len, trim(col1) col2, length(trim(col1)) col2_len, nvl(trim(col1),\u0026#39;-\u0026#39;) col3, length(nvl(trim(col1),\u0026#39;-\u0026#39;)) col3_len from data_list ;     order by #   order by asc/desc ...  select * from my_table_1 order by column_2 asc,column_1 desc,column_3     count / sum / avg / min / max / median /stddev / round / trunc / ceil / floor #   count / sum / avg / min / max / median /stddev / round / trunc / ceil / floor  ...  select count(column_1), sum(column_2), avg(column_2), min(column_2), max(column_2), median(column_2), stddev(column_2), round(avg(column_2)), round(stddev(column_2),2), trunc(avg(column_2)), ceil(avg(column_2)), floor(avg(column_2)) from my_table_1 ;     count / sum / avg / min / max / median /stddev / round / trunc / ceil / floor #   count / sum / avg / min / max / median /stddev / round / trunc / ceil / floor  ...  select substr(column_1,1,1),sum(column_2) from my_table_1 group by substr(column_1,1,1) ; select substr(column_1,1,1),sum(column_2) from my_table_1 group by substr(column_1,1,1) having sum(column_2) \u0026gt;= 30 ; select * from my_table_1 where substr(column_1,1,1) = \u0026#39;김\u0026#39; ; select substr(column_1,1,1),sum(column_2),avg(column_2) from my_table_1 where substr(column_1,1,1) = \u0026#39;김\u0026#39; group by substr(column_1,1,1) ; select substr(column_1,1,1),sum(column_2),avg(column_2) from my_table_1 where substr(column_1,1,1) = \u0026#39;김\u0026#39; and column_2 \u0026gt;= 20 group by substr(column_1,1,1) ;      다음글  "});index.add({'id':10,'href':'/docs/documents/backend/sql/sql02/','title':"SQL Basic 2",'section':"SQL",'content':"SQL Basic 2 #    다음글  "});index.add({'id':11,'href':'/docs/documents/backend/go/go01/','title':"GO Basic",'section':"Go",'content':"GO Basic #   Go 기본적인 문법 정리. 하기 사이트 참조.\n예제로 배우는 Go 프로그래밍\nHello World #  package main func main() { println(\u0026#34;Hello World!\u0026#34;) } Declare #  선언 및 할당 방식\n declare ...  package main func main() { // 선언 및 할당 \tvar a int var b float32 = 11. println(a, b) // 선언 및 할당 \ta = 10 b = 12.0 println(a, b) // 상수 \tconst c int = 10 const d string = \u0026#34;Hello\u0026#34; println(c, d) // 상수 나열 \tconst ( Visa = \u0026#34;Visa\u0026#34; Master = \u0026#34;MasterCard\u0026#34; Amex = \u0026#34;American Express\u0026#34; ) println(Visa, Master, Amex) // 상수 나열 \tconst ( Apple = iota Grape Orage ) println(Apple, Grape, Orage) }     Reserved Keywords #  GO 25개 예약어\nbreak, case, chan, const, continue, const, default, const, defer, else,fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var  Declaration of Varialbe and Operators #  변수 선언 및 연산자\n declaration of varialbe ...  func main() { textLine1 := `첫번째 줄입니다.\\n 두번째 줄입니다.\\n 세번째 줄입니다` fmt.Println(textLine1) textLine2 := \u0026#34;첫번째 줄입니다.\\n두번째 줄입니다.\\n세번째 줄입니다\u0026#34; fmt.Println(textLine2) textLine3 := \u0026#34;첫번째 줄입니다.\\n\u0026#34; + \u0026#34;두번째 줄입니다.\\n\u0026#34; + \u0026#34;세번째 줄입니다\u0026#34; fmt.Println(textLine3) var a int = 100 var b uint = uint(a) var c float32 = float32(a) println(a, b, c) str := \u0026#34;ABCDEFG\u0026#34; byt := []byte(str) stg := string(byt) println(str, byt, byt[0], byt[1], stg) }      operators ...  package main func main() { var a int = 7 var b int = 3 //산술연산자 \tvar c = (a + b) / 5 println(a, b, c) c++ println(c) // 관계연산자 \tif b == c { println(\u0026#34;b==c\u0026#34;) } else { println(\u0026#34;b!=c\u0026#34;) } if a != b { println(\u0026#34;a!=b\u0026#34;) } else { println(\u0026#34;a==b\u0026#34;) } if a \u0026gt;= b { println(\u0026#34;a\u0026gt;=b\u0026#34;) } else { println(\u0026#34;a\u0026lt; b\u0026#34;) } // 논리 연산자 \tif a \u0026gt;= b \u0026amp;\u0026amp; b == c { println(\u0026#34;a\u0026gt;=b \u0026amp;\u0026amp; b==c\u0026#34;) } else { println(\u0026#34;not(a\u0026gt;=b \u0026amp;\u0026amp; b==c)\u0026#34;) } if a \u0026gt;= b || b \u0026gt; c { println(\u0026#34;a\u0026gt;=b || b\u0026lt;\u0026gt;c\u0026#34;) } else { println(\u0026#34;not(a\u0026gt;=b || b\u0026lt;\u0026gt;c)\u0026#34;) } // Bitwise 연산자 \tvar d = (a \u0026amp; b) var e = (a \u0026amp; b) \u0026lt;\u0026lt; 1 println(d, e) // 할당연산자 \ta = 10 println(a) a *= 10 println(a) a \u0026gt;\u0026gt;= 1 println(a) a |= 1 println(a) // 포인터 연산자 \tvar x int = 10 var p = \u0026amp;x //x\u0026#39;s address  // x = value \t// \u0026amp;x = x\u0026#39;s address \t// p = \u0026amp;x = x\u0026#39;s address \t// *p = x\u0026#39;s address\u0026#39;s value \t// \u0026amp;p = p\u0026#39;s address \tprintln(x, \u0026amp;x, p, *p, \u0026amp;p) x++ println(x, \u0026amp;x, p, *p, \u0026amp;p) }     Conditional Statement #   conditional statement ...  package main func main() { var a = 1 if a == 1 { println(\u0026#34;One\u0026#34;) } else if a == 2 { println(\u0026#34;Two\u0026#34;) } else { println(\u0026#34;Other\u0026#34;) } // Optional Statement \tif b := 1; b \u0026lt; 10 { println(b) } var name string var category = 1 switch category { case 1: name = \u0026#34;Paper Book\u0026#34; case 2: name = \u0026#34;eBook\u0026#34; case 3, 4: name = \u0026#34;Blog\u0026#34; default: name = \u0026#34;Other\u0026#34; } println(name) // Expression을 사용한 경우 \tswitch x := category \u0026lt;\u0026lt; 2; x - 1 { //... \t} var score = 80 switch { case score \u0026gt;= 90: println(\u0026#34;A\u0026#34;) case score \u0026gt;= 80: println(\u0026#34;B\u0026#34;) case score \u0026gt;= 70: println(\u0026#34;C\u0026#34;) case score \u0026gt;= 60: println(\u0026#34;D\u0026#34;) default: println(\u0026#34;No Hope\u0026#34;) } }     Iteration #   iteration ...  package main func main() { sum := 0 for i := 1; i \u0026lt;= 100; i++ { sum += i } println(sum) n := 2 for n \u0026lt; 100 { n = n * n } println(n) names := []string{\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;geh\u0026#34;} for index, name := range names { println(index, name) } b := 0 L1: for { if b == 0 { break L1 } } println(\u0026#34;L1\u0026#34;, b) var a = 1 for a \u0026lt; 15 { if a == 5 { a += 4 continue } a++ println(\u0026#34;In\u0026#34;, a) if a \u0026gt; 9 { println(\u0026#34;Here\u0026#34;, a) break } } if a == 11 { goto END } println(a) END: println(\u0026#34;End\u0026#34;, a) }     \u0026lsquo;goto END\u0026rsquo;는 END 레이블로 이동 \u0026lsquo;break L1\u0026rsquo;은 break 레이블로 위치를 이동.\nMethod #   method ...  package main func main() { msg := \u0026#34;Hello\u0026#34; // Function \tsay(msg) println(\u0026#34;2\u0026#34;, msg) // Pass By Reference \tsayC(\u0026amp;msg) println(\u0026#34;4\u0026#34;, msg) // Variadic Function \tsayV(\u0026#34;this\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;pen\u0026#34;) sayV(\u0026#34;and\u0026#34;, \u0026#34;pineapple\u0026#34;) // Return Value \ttotal := sum(1, 7, 3, 5, 9) println(total) // Return Multiple Value \tcount, total := sumC(1, 7, 3, 5, 9) println(count, total) // Named Return Parameter \tcount, total = sumN(1, 7, 3, 5, 9) println(\u0026#34;Named Return Param\u0026#34;, count, total) // Anonymous Function \tsumA := func(n ...int) int { //익명함수 정의 \ts := 0 for _, i := range n { s += i } return s } result := sumA(1, 2, 3, 4, 5) println(\u0026#34;result :\u0026#34;, result) // add anonymouse function : 함수명을 갖지 않는 함수 \tadd := func(i int, j int) int { return i + j } // send anonumous function to other function \tr1 := calc(add, 10, 20) println(\u0026#34;r1 :\u0026#34;, r1) // First-Calss function : 다른함수에 파라미터나 리턴값으로 사용되는 함수 \tr2 := calc(func(x int, y int) int { return x - y }, 10, 20) println(\u0026#34;r2 :\u0026#34;, r2) // prototype function \tr3 := calcP(add, 10, 25) println(\u0026#34;r3 :\u0026#34;, r3) // closure : 함수 바깥에 있는 변수를 참조하는 Function Value \tnext1 := nextValue() println(\u0026#34;next1\u0026#34;, next1()) println(\u0026#34;next1\u0026#34;, next1()) println(\u0026#34;next1\u0026#34;, next1()) next2 := nextValue() println(\u0026#34;next2\u0026#34;, next2()) println(\u0026#34;next2\u0026#34;, next2()) println(\u0026#34;next1\u0026#34;, next1()) } func say(msg string) { println(\u0026#34;1\u0026#34;, msg) } func sayC(msg *string) { println(\u0026#34;3\u0026#34;, *msg) *msg = \u0026#34;World\u0026#34; } func sayV(msg ...string) { for _, s := range msg { println(s) } } func sum(nums ...int) int { s := 0 for _, n := range nums { s += n } return s } func sumC(nums ...int) (int, int) { s := 0 count := 0 for _, n := range nums { s += n count++ } return count, s } func sumN(nums ...int) (count int, total int) { for _, n := range nums { total += n } count = len(nums) return } func calc(f func(int, int) int, a int, b int) int { result := f(a, b) return result } // prototype type calculator func(int, int) int // use prototype function func calcP(f calculator, a int, b int) int { result := f(a, b) return result } // closure func nextValue() func() int { i := 0 return func() int { i++ return i } }     Array / Slice / Map #  배열은 연속적인 메모리 공간에 동일한 타입의 데이터를 순서적으로 저장하는 자료구조. 슬라이스는 내부적으로 배열에 기초하여 만들어졌으나 크기를 동적으로 변할 수도 있고 부분 배열을 발췌할 수 있음.\n array and slice ...  package main import \u0026#34;fmt\u0026#34; func main() { // Array \tvar arr1 [3]int arr1[0] = 1 arr1[1] = 2 arr1[2] = 3 println(\u0026#34;arr1[0] : \u0026#34;, arr1[0], \u0026#34;arr1[1] : \u0026#34;, arr1[1], \u0026#34;arr1[2] : \u0026#34;, arr1[2]) var arr2 = [3]int{4, 5, 6} var arr3 = [...]int{7, 8, 9} println(\u0026#34;arr2[0] : \u0026#34;, arr2[0], \u0026#34;arr2[1] : \u0026#34;, arr2[1], \u0026#34;arr2[2] : \u0026#34;, arr2[2]) println(\u0026#34;arr3[0] : \u0026#34;, arr3[0], \u0026#34;arr3[1] : \u0026#34;, arr3[1], \u0026#34;arr3[2] : \u0026#34;, arr3[2]) // multi array 1 \tvar arr4 [3][4][5]int arr4[0][1][2] = 10 println(\u0026#34;arr4[0][1][2] : \u0026#34;, arr4[0][1][2]) // multi array 2 \tvar arr5 = [2][3]int{{1, 2, 3}, {4, 5, 6}} println(\u0026#34;arr5[1][2] : \u0026#34;, arr5[1][2]) // Slice \tvar slc1 []int slc1 = []int{1, 2, 3} slc1[1] = 10 fmt.Println(\u0026#34;slc1 : \u0026#34;, slc1) // Slice with Make \tslc2 := make([]int, 5, 10) println(len(slc2), cap(slc2)) fmt.Println(slc2) // Nil Slice \tvar slc3 []int if slc3 == nil { println(\u0026#34;Nil Slice\u0026#34;) } println(len(slc3), cap(slc3)) fmt.Println(slc3) // Sub Slice \tslc4 := []int{0, 1, 2, 3, 4, 5} fmt.Println(\u0026#34;[0:1] : \u0026#34;, slc4[0:1], \u0026#34;,[2:5] : \u0026#34;, slc4[2:5], \u0026#34;,[1:] : \u0026#34;, slc4[1:], \u0026#34;,[:5] : \u0026#34;, slc4[:5]) // Slice append / copy \tslc5 := []int{0, 1} // append one \tslc5 = append(slc5, 2) // append multiple \tslc5 = append(slc5, 3, 4, 5) fmt.Println(slc5) // Underlying array \tslc6 := make([]int, 0, 3) for i := 1; i \u0026lt; 15; i++ { slc6 = append(slc6, i) fmt.Println(\u0026#34;slc6 len, cap : \u0026#34;, len(slc6), cap(slc6)) } fmt.Println(slc6) // append slice \u0026amp; ellipsis(...) \tslc7 := []int{1, 2, 3} slc8 := []int{4, 5, 6} slc7 = append(slc7, slc8...) fmt.Println(slc7) // slice copy \tslc9 := []int{0, 1, 2} slc10 := make([]int, len(slc9), cap(slc9)*2) copy(slc10, slc9) fmt.Println(slc10) println(len(slc10), cap(slc10)) }     Map은 Key에 대응하는 Value를 찾는 Hash Table을 구현한 자료구조.\n map ...  package main import \u0026#34;fmt\u0026#34; func main() { // map 1 \tvar map01 map[int]string map01 = make(map[int]string) map01[901] = \u0026#34;Apple\u0026#34; map01[134] = \u0026#34;Grape\u0026#34; map01[777] = \u0026#34;Tomato\u0026#34; str := map01[134] println(\u0026#34;134 :\u0026#34;, str) str = map01[999] println(\u0026#34;999 :\u0026#34;, str) str = map01[777] println(\u0026#34;777 :\u0026#34;, str) delete(map01, 777) println(\u0026#34;777 :\u0026#34;, str) // map key check \tmap02 := map[string]string{ \u0026#34;GOO\u0026#34;: \u0026#34;Google\u0026#34;, \u0026#34;MSF\u0026#34;: \u0026#34;Microsoft\u0026#34;, \u0026#34;FBK\u0026#34;: \u0026#34;Facebook\u0026#34;, \u0026#34;AMZ\u0026#34;: \u0026#34;Amazon\u0026#34;, } val, exists := map02[\u0026#34;MSF\u0026#34;] if !exists { println(\u0026#34;No MSF MAP02\u0026#34;) } println(\u0026#34;Exists :\u0026#34;, val, exists) // map for loop \tmap03 := map[string]string{ \u0026#34;A\u0026#34;: \u0026#34;Apple\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;Banana\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;Charlie\u0026#34;, } for key, val := range map03 { fmt.Println(key, val) } }     Package #   package  ...  /lib/lib01.go\npackage lib01 import \u0026#34;fmt\u0026#34; var pop map[string]string func init() { pop = make(map[string]string) pop[\u0026#34;A\u0026#34;] = \u0026#34;Apple\u0026#34; pop[\u0026#34;B\u0026#34;] = \u0026#34;Banana\u0026#34; pop[\u0026#34;C\u0026#34;] = \u0026#34;Chocolate\u0026#34; } func GetItems(item string) string { return pop[item] } func getKeys() { for _, kv := range pop { fmt.Println(kv) } } main.go\npackage main import lib01 \u0026#34;./lib\u0026#34; func main() { // package \titem := lib01.GetItems(\u0026#34;A\u0026#34;) println(item) }     Struct #   struct  ...  package main import \u0026#34;fmt\u0026#34; // struct type person struct { name string age int } type dict struct { data map[int]string } func newDict() *dict { dic := dict{} dic.data = map[int]string{} return \u0026amp;dic } func main() { // person struct \tper1 := person{} per1.name = \u0026#34;Lee\u0026#34; per1.age = 18 fmt.Println(per1) // person struct 2 \tvar per2 person per2 = person{\u0026#34;Bob\u0026#34;, 20} per3 := person{name: \u0026#34;Sean\u0026#34;, age: 30} fmt.Println(per2) fmt.Println(per3) // person struct 3 \tper4 := new(person) per4.name = \u0026#34;Kim\u0026#34; fmt.Println(per4) // constructor \tdic1 := newDict() dic1.data[1] = \u0026#34;A\u0026#34; fmt.Println(dic1) }     Method / Interface #   method / interface ...  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) // struct type Rect struct { width, height int } // method func (r Rect) area() int { return r.width * r.height } // method func (r *Rect) area2() int { r.width++ return r.width * r.height } // interface type Shpe interface { area() float64 peri() float64 } type RectF struct { width, height float64 } type CircF struct { radius float64 } // interface func (r RectF) area() float64 { return r.width * r.height } func (r RectF) peri() float64 { return 2 * (r.width + r.height) } func (c CircF) area() float64 { return math.Pi * c.radius * c.radius } func (c CircF) peri() float64 { return 2 * math.Pi * c.radius } func showArea(shpe ...Shpe) { for _, s := range shpe { a := s.area() println(a) } } func main() { rect := Rect{10, 20} area := rect.area() println(area) area = rect.area2() println(area) rectf := RectF{10., 20.} circf := CircF{10} showArea(rectf, circf) // empty interface \tvar type_x interface{} type_x = 1 type_x = \u0026#34;Jake\u0026#34; printIt(type_x) // Type Assertion \tvar type_y interface{} = 1 var_i := type_y var_j := type_y.(int) println(var_i) // pointer address \tprintln(var_j) // 1 } func printIt(type_v interface{}) { fmt.Println(type_v) }     Error / Defer / Panic / Recover #   error / defer / panic / recover ...  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // // Error 처리 \t// f, err := os.Open(\u0026#34;C:\\\\temp\\\\1.txt\u0026#34;) \t// if err != nil { \t// println(\u0026#34;Error!!!\u0026#34;) \t// log.Fatal(err.Error()) \t// } \t// println(f.Name())  // // defer \t// f, err := os.Open(\u0026#34;1.txt\u0026#34;) \t// if err != nil { \t// panic(err) \t// } \t// defer f.Close() \t// bytes := make([]byte, 1024) \t// f.Read(bytes) \t// println(len(bytes))  // panic \topenFile(\u0026#34;Invalid.txt\u0026#34;) println(\u0026#34;Done!!!\u0026#34;) } func openFile(fn string) { // defer에 의한 recover 처리 \tdefer func() { if r := recover(); r != nil { fmt.Println(\u0026#34;Open Error\u0026#34;, r) } }() f, err := os.Open(fn) if err != nil { println(\u0026#34;Panic Herer!!!\u0026#34;) panic(err) } defer f.Close() }     Goroutine / Channel #   gorutine / channel ...  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func say(s string) { for i := 0; i \u0026lt; 3; i++ { fmt.Println(s, \u0026#34;***\u0026#34;, i) time.Sleep(time.Second * 1) } } func say2(s string) { for i := 0; i \u0026lt;= 1000000; i++ { fmt.Println(s, \u0026#34;***\u0026#34;, i) } } func main() { // goroutine \tsay(\u0026#34;Sync\u0026#34;) go say(\u0026#34;Async1\u0026#34;) go say(\u0026#34;Async2\u0026#34;) go say(\u0026#34;Async3\u0026#34;) time.Sleep(time.Second * 3) // anonymous goroutine \tvar wait sync.WaitGroup wait.Add(2) go func() { defer wait.Done() fmt.Println(\u0026#34;Hello\u0026#34;) }() go func(msg string) { defer wait.Done() fmt.Println(msg) }(\u0026#34;Hi\u0026#34;) wait.Wait() // Concurrency vs Parallelism \truntime.GOMAXPROCS(3) go say2(\u0026#34;Async1\u0026#34;) go say2(\u0026#34;Async2\u0026#34;) go say2(\u0026#34;Async3\u0026#34;) time.Sleep(time.Second * 12) // channel \tch := make(chan int) go func() { ch \u0026lt;- 123 }() var i int i = \u0026lt;-ch println(i) // channel 2 \tdone := make(chan bool) go func() { for i := 0; i \u0026lt; 1000; i++ { fmt.Println(i) } done \u0026lt;- true }() \u0026lt;-done // channel deadlock \t// c := make(chan int) \t// c \u0026lt;- 1 \t// fmt.Println(\u0026lt;-c)  // buffer channel \tch = make(chan int, 1) ch \u0026lt;- 101 fmt.Println(\u0026lt;-ch) // channel sending/receiving \tchstr := make(chan string, 1) sendChnn(chstr) receiveChnn(chstr) // channel close \tch = make(chan int, 3) ch \u0026lt;- 1 ch \u0026lt;- 2 ch \u0026lt;- 3 close(ch) println(\u0026lt;-ch) println(\u0026lt;-ch) if _, success := \u0026lt;-ch; !success { println(\u0026#34;no data\u0026#34;) } // channel receiving 1 \tch = make(chan int, 5) ch \u0026lt;- 1 ch \u0026lt;- 2 ch \u0026lt;- 3 ch \u0026lt;- 3 ch \u0026lt;- 2 close(ch) for i := range ch { println(i) } // channel receiving 2 \tch = make(chan int, 5) ch \u0026lt;- 1 ch \u0026lt;- 2 ch \u0026lt;- 3 ch \u0026lt;- 1 ch \u0026lt;- 4 close(ch) for { if i, success := \u0026lt;-ch; success { println(i) } else { break } } // channel select \tdone1 := make(chan bool) done2 := make(chan bool) go run1(done1) go run2(done2) EXIT: for { select { case \u0026lt;-done1: println(\u0026#34;run1 finished\u0026#34;) case \u0026lt;-done2: println(\u0026#34;run2 finished\u0026#34;) break EXIT } } } func run1(done chan bool) { time.Sleep(1 * time.Second) done \u0026lt;- true } func run2(done chan bool) { time.Sleep(2 * time.Second) done \u0026lt;- true } func sendChnn(ch chan\u0026lt;- string) { ch \u0026lt;- \u0026#34;Data\u0026#34; } func receiveChnn(ch \u0026lt;-chan string) { data := \u0026lt;-ch fmt.Println(data) }     [github-go_basic]](https://github.com/prokoptasis/go_basic.git)\n 다음글  "});index.add({'id':12,'href':'/docs/documents/backend/rust/rust01/','title':"Rust Basic",'section':"Rust",'content':"Rust Basic 1 #   Rust는 시스템 레벨의 프로그래밍 언어. C/C++의 대체 언어의 특성. 타입 안전성, 메모리 안전성, 동시성, 그리고 성능에도 초점을 맞추어 대규모, 고성능 소프트웨어의 개발을 작성하도록 설계됨. 무효한 메모리 접근을 예방하기 위해 빌림 검사와 같은 독특한 특성을 지님.\n하기 링크 참조.\n The Rust Programming Language The Rust Programming Language (KOR)  Hello World #  Hello World\ncargo init rust_hello --bin cd rust_hello cargo run fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } Guessing Game #   source ...  extern crate rand; use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { // 첫 줄 출력 \tprintln!(\u0026#34;Guess the number!\u0026#34;); // 1 부터 100까지의 숫자를 Rangdom으로 생성 후 secret_nmber로 선언  let secret_number = rand::thread_rng().gen_range(1, 101); loop { // 질문 출력  println!(\u0026#34;Please input your guess.\u0026#34;); // guess를 mutable 형태의 string으로 생성  let mut guess = String::new(); // guess의 입력을 받음  io::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026#34;Failed to read line\u0026#34;); // guess를 trim하고 숫자로 전환  let guess: u32 = match guess.trim().parse() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; continue, }; // 사용자의 guess를 재출력  println!(\u0026#34;You guessed: {}\u0026#34;, guess); // secret_number의 숫자를 비교하여 결과를 출력  match guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026#34;Too small!\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;Too big!\u0026#34;), Ordering::Equal =\u0026gt; { println!(\u0026#34;You win!\u0026#34;); break; } } } }      source check ...  let foo = 5;\t// immutable let mut bar = 5;\t// mutable let baz = String::new(); 기본적으로 let과 let mut은 변수의 가변성에 차이를 두고 다르게 선언하는 것을 의미.String::new는 String타입의 연관함수로 OO에서 클래스의 인스턴스 없이 호출할 수 있는 정적 메소드와 동일.\nio::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026#34;Failed to read line\u0026#34;); 프로그램의 시작점에 \u0026lsquo;use std::io\u0026rsquo;로 명시되었기 때문에 함수 호출시의 io::stdin은 표준 입력 핸들 타입인 std::io::Stdin을 돌려줌. \u0026amp;mut guess를 넘겨받아 사용자의 입력을 저장하게 됨. 이때 사용자의 입력은 지속적으로 추가됨으로 가변 문자열이어야 함. 이때 \u0026lsquo;\u0026amp;mut\u0026rsquo; 인 이유는 Rust에서는 \u0026lsquo;\u0026amp;\u0026rsquo; c참조자의 기본 속성이 안전성을 위해 Immutable임으로 명시적으로 가변임을 지정할 필요가 있음. \u0026lsquo;.expect\u0026rsquo; 는 에러를 처리하는 메소드로 인스터스가 Error를 낼 경우 해당 메세지를 출력하며 동작을 멈추게 됨. 만일 \u0026lsquo;expec\u0026rsquo;없이 컴파일 한다면 경고가 표시됨.\n// place holder println!(\u0026#34;You guessed: {}\u0026#34;, guess); // place holder 지정 println!(\u0026#34;You guessed: {g} number {n}\u0026#34;, g= guess,n = number); 위 문장에서 \u0026lsquo;{}\u0026rsquo; 부분은 변경자(Place Holder)로 guess의 표시 위치를 나타냄. 하나 이상의 Place Holder를 아래처럼 지정하여 사용할 수도 있음.\n// Cargo.toml [dependencies] rand = \u0026#34;0.4.0\u0026#34; Random 처리를 위해 Cargo.toml에 의존성을 추가하여 rand crate를 명시함.\nmatch guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026#34;Too small!\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;Too big!\u0026#34;), Ordering::Equal =\u0026gt; { println!(\u0026#34;You win!\u0026#34;); break; } 사용자가 입력한 guess 숫자와 Random으로 생성된 secret_number를 비교하는 메소드. std 표준 라이브러리로부터 std::cmp::Ordering Scope를 가져와서 Ordering 타입을 사용하는 형태.\nlet guess: u32 = match guess.trim().parse() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; continue, }; 입력된 guess의 문자열을 secret_number와 비교하기 위해 숫자로 바꾸는 라인. 기존 guess 변수를 triming된 숫자로 Shadowing하여 재사용하는 방식으로 구현됨. \u0026lsquo;guess.trim()\u0026lsquo;을 통해 사용자 입력시 들어온 Enter의 개행문자를 제거하고 \u0026lsquo;parse()\u0026lsquo;를 통해 숫자열로 파싱. 이때 u32와 같이 정확한 타입을 명시해야함. 사용자가 입력한 숫자에 특수문자 같은 것이 포함되어 u32로 전환할 수 없을 경우를 대비해서 expect와 같은 별도 처리가 필요할 수도 있음. 여기서는 Error가 들어올경우 continue를 통해 다음 Loop로 다시 시작되도록 처리 됨.\nloop { ... match guess.cmp(\u0026amp;secret_number) { ... Ordering::Equal =\u0026gt; { println!(\u0026#34;You win!\u0026#34;); break; } } main 프로그램은 Ordering::Equal이 나올때까지 Loop로 들어가 반복되며 수행됨.\n   Common Programming Concepts #  Variables / Mutability / Data Types\n variables / mutability / data types ...  fn main() { // immutable  let x = 5; println!(\u0026#34;The value of x is: {}\u0026#34;, x); // x = 7; // connot assign twice to immutable variable  println!(\u0026#34;The value of x is: {}\u0026#34;, x); // shadowing  let x = 10; println!(\u0026#34;The value of x is: {}\u0026#34;, x); // shadowing 2  let spaces = \u0026#34; \u0026#34;; println!(\u0026#34;Spaces: {}\u0026#34;, spaces); let spaces = spaces.len(); println!(\u0026#34;Spaces: {}\u0026#34;, spaces); // mutable  let mut x = 6; println!(\u0026#34;The value of x is: {}\u0026#34;, x); x = 7; // connot assign twice to immutable variable  println!(\u0026#34;The value of x is: {}\u0026#34;, x); // mutable  let mut spaces = \u0026#34; \u0026#34;; println!(\u0026#34;Spaces: {}\u0026#34;, spaces); // spaces = spaces.len(); //expected `\u0026amp;str`, found `usize`  println!(\u0026#34;Spaces: {}\u0026#34;, spaces); // const  const MAX_POINTS: u32 = 100_000; println!(\u0026#34;MAX_POINTS: {}\u0026#34;, MAX_POINTS); // let guess = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); // consider giving `guess` a type  let guess: u32 = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); // float  let f1: f64 = 2.0; let f2: f32 = 3.0; println!(\u0026#34;{},{}\u0026#34;, f1, f2); // let addition  let sum = 5 + 10; // let subtraction  let difference = 95.5 - 4.3; // let multiplication  let product = 4 * 30; // let division  let quotient = 56.7 / 32.2; // let remainder  let remainder = 43 % 5; println!( \u0026#34;let calc {},{},{},{},{}\u0026#34;, sum, difference, product, quotient, remainder ); // boolean  let t = true; let f: bool = false; println!(\u0026#34;let bool {},{}\u0026#34;, t, f); // character  let c = \u0026#39;z\u0026#39;; let z = \u0026#39;ℤ\u0026#39;; let cat = \u0026#39;😻\u0026#39;; println!(\u0026#34;let char {},{},{}\u0026#34;, c, z, cat); // tuple  let tup: (i32, f64, u8) = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026#34;x : {}, y : {}, z : {}\u0026#34;, x, y, z); let x: (i32, f64, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8) = (500, 6.4, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11); let five_hundred = x.0; println!(\u0026#34;five_hundred : {}, x11 : {}\u0026#34;, five_hundred, x.11); // Array  let ary = [1, 2, 3, 4, 5]; let mon = [ \u0026#34;Jan\u0026#34;, \u0026#34;Feb\u0026#34;, \u0026#34;Mar\u0026#34;, \u0026#34;Apr\u0026#34;, \u0026#34;May\u0026#34;, \u0026#34;Jun\u0026#34;, \u0026#34;Jul\u0026#34;, \u0026#34;Aug\u0026#34;, \u0026#34;Sep\u0026#34;, \u0026#34;Oct\u0026#34;, \u0026#34;Nov\u0026#34;, \u0026#34;Dec\u0026#34;, ]; let index = 4; // let index = 12; // panicked at \u0026#39;index out of bounds: the len is 12 but the index is 12\u0026#39;  let frst = ary[0]; let scnd = mon[1]; let thrd = mon[index]; println!(\u0026#34;frst : {} , scnd : {} , thrd : {}\u0026#34;, frst, scnd, thrd); }     Functions\n functions ...  fn main() { println!(\u0026#34;Hello, world!\u0026#34;); // function  function_a(); // function parameter  function_b(3); // function parameters  function_c(3, 5); // statement  let stmt1 = 6; println!(\u0026#34;stmt1 : {}\u0026#34;, stmt1); // let stmt1 = (let stmt2 = 5); // variable declaration using `let` is a statement  let stmt1 = 5; // expression  let stmt2 = { let stmt1 = 3; stmt1 + 1 }; println!(\u0026#34;stmt1 : {}, stmt2 : {}\u0026#34;, stmt1, stmt2); // function with return values  let stmt3 = function_d(); println!(\u0026#34;stmt3 : {}\u0026#34;, stmt3); // function with return values  let stmt4 = function_e(5); println!(\u0026#34;stmt4 : {}\u0026#34;, stmt4); } fn function_a() { println!(\u0026#34;Hello, again!\u0026#34;) } fn function_b(x: i32) { for i in 0..x { println!(\u0026#34;{} : Hello, again!\u0026#34;, i) } } fn function_c(x: i32, y: i32) { for i in x..y { println!(\u0026#34;{}: Hello, again! {},{}\u0026#34;, i, x, y) } } fn function_d() -\u0026gt; i32 { 5 } fn function_e(x: i32) -\u0026gt; i32 { // without semicolon  x + 1 }     Contrl Flow\n control flow ...  fn main() { // if else 1  let number = 3; if number \u0026lt; 5 { println!(\u0026#34;{} condition was true\u0026#34;, number); } else { println!(\u0026#34;{} condition was false\u0026#34;, number); }; // if else 2  let number = 7; if number \u0026lt; 5 { println!(\u0026#34;{} condition was true\u0026#34;, number); } else { println!(\u0026#34;{} condition was false\u0026#34;, number); }; // if else 3  if number != 0 { println!(\u0026#34;{} number was soething other than zero\u0026#34;, number); }; // if else 4  if number % 4 == 0 { println!(\u0026#34;{} number is divisible by 4\u0026#34;, number) } else if number % 3 == 0 { println!(\u0026#34;{} number is divisible by 3\u0026#34;, number) } else if number % 2 == 0 { println!(\u0026#34;{} number is divisible by 2\u0026#34;, number) } else { println!(\u0026#34;{} number is not divisible by 4,3,2\u0026#34;, number) }; // if with let  let cond = true; let numb = if cond { 5 } else { 6 }; println!(\u0026#34;This value of numb is : {}\u0026#34;, numb); // while  let mut numc = 3; while numc != 0 { println!(\u0026#34;{}\u0026#34;, numc); numc = numc - 1; } println!(\u0026#34;numc : {}\u0026#34;, numc); // for collection  let arry = [10, 20, 30, 40, 50]; for elem in arry.iter() { println!(\u0026#34;the value is: {}\u0026#34;, elem); } // for range rev  for numd in (1..4).rev() { println!(\u0026#34;{}!\u0026#34;, numd); } }     Understanding Ownership #  Stack vs Heap 스택은 값을 받아들인 순서대로 저장하고 반대 방향으로 값을 지우는 방식. (Last In, First Out) 힙은 특정 공간을 할당하고 위치 검색을 통해 값을 불러 오는 방식.\n   구분 Stack Heap     관리 CPU Programmer   속도 빠름 느림   범위 지역 전역   크기 제한 제한없음    Shallow Copy vs Deep Copy Rust는 Shallow Copy를 Move라 표현. 명시적으로 표시하지 않는 이상 Deep Copy는 발생되지 않음.\n ownership ...  fn main() { // move  let str1 = String::from(\u0026#34;hello\u0026#34;); let str2 = str1; // shallow copy  //println!(\u0026#34;{}\u0026#34;, str1); // move occurs because `str1` has type `std::string::String`  println!(\u0026#34;{}\u0026#34;, str2); // function takes ownership  let str3 = String::from(\u0026#34;world\u0026#34;); take_owns(str3); //println!(\u0026#34;{}\u0026#34;, str3); //value borrowed here after move  // integer copy to function  let intg = 5; make_copy(5); println!(\u0026#34;{}\u0026#34;, intg); //  let str4 = String::from(\u0026#34;again\u0026#34;); let str5 = take_back(str4); //println!(\u0026#34;{}\u0026#34;, str4); //move occurs because `str4` has type `std::string::String`  println!(\u0026#34;{}\u0026#34;, str5); // Reference  let str6 = String::from(\u0026#34;This is a pen\u0026#34;); let leng = calc_leng(\u0026amp;str6); println!(\u0026#34;The length of \u0026#39;{}\u0026#39; is {}\u0026#34;, str6, leng); // Reference  let mut str7 = String::from(\u0026#34;This is a book\u0026#34;); chng_strg(\u0026amp;mut str7); println!(\u0026#34;{}\u0026#34;, str7); // Reference mutable  let mut str8 = String::from(\u0026#34;text1\u0026#34;); let str9 = \u0026amp;mut str8; //first mutable borrow occurs here  // let str10 = \u0026amp;mut str8; //second mutable borrow occurs here  println!(\u0026#34;{}\u0026#34;, str9); // println!(\u0026#34;{}\u0026#34;, str10)  // Reference mutable 1  let mut str11 = String::from(\u0026#34;text2\u0026#34;); { let str12 = \u0026amp;mut str11; println!(\u0026#34;{}\u0026#34;, str12); } let str13 = \u0026amp;mut str11; println!(\u0026#34;{}\u0026#34;, str13); // Reference mutable 2  let mut str14 = String::from(\u0026#34;text3\u0026#34;); let str15 = \u0026amp;str14; let str16 = \u0026amp;str14; // let str17 = \u0026amp;mut str14; //mutable borrow occurs here  println!(\u0026#34;{}\u0026#34;, str15); println!(\u0026#34;{}\u0026#34;, str16); // println!(\u0026#34;{}\u0026#34;, str17);  // dangling references  let noth = dang_refr(); println!(); // slice  let mut str17 = String::from(\u0026#34;fffirst words\u0026#34;); let str18 = frst_word(\u0026amp;str17); str17.clear(); println!(\u0026#34;{}\u0026#34;, str18); // string slice  let str19 = String::from(\u0026#34;hello world\u0026#34;); let str20 = \u0026amp;str19[0..5]; let str21 = \u0026amp;str19[6..11]; println!(\u0026#34;{},{},{}\u0026#34;, str19, str20, str21); let str22 = \u0026amp;str19[..5]; let leng = str19.len(); let str23 = \u0026amp;str19[6..leng]; println!(\u0026#34;{},{},{}\u0026#34;, str22, leng, str23); // literal slice  let mut str24 = String::from(\u0026#34;hello world\u0026#34;); let str25 = frst_word_s(\u0026amp;str24); // str24.clear(); // mutable borrow occurs here  println!(\u0026#34;str25 {}\u0026#34;, str25); // literal slice  let str26 = String::from(\u0026#34;hello world\u0026#34;); let str27 = frst_word_s(\u0026amp;str26[..]); let str28 = \u0026#34;HELLO WORLD\u0026#34;; let str27 = frst_word_s(\u0026amp;str28[..]); let str27 = frst_word_s(str28); println!(\u0026#34;str27 {}\u0026#34;, str27); // etc slice  let intg = [1, 2, 3, 4, 5]; let ints = \u0026amp;intg[1..3]; println!(\u0026#34;{}{}\u0026#34;, ints[0], ints[1]) } fn take_owns(strg: String) { println!(\u0026#34;{}\u0026#34;, strg); } fn make_copy(intg: i32) { println!(\u0026#34;{}\u0026#34;, intg); } fn take_back(strg: String) -\u0026gt; String { strg } fn calc_leng(strg: \u0026amp;String) -\u0026gt; usize { strg.len() } fn chng_strg(strg: \u0026amp;mut String) { strg.push_str(\u0026#34;,Hello?\u0026#34;); } // this function\u0026#39;s return type contains a borrowed value // fn dang_refr() -\u0026gt; \u0026amp;String { // let strg = String::from(\u0026#34;Eh?\u0026#34;); // \u0026amp;strg // }  fn dang_refr() -\u0026gt; String { let strg = String::from(\u0026#34;Eh?\u0026#34;); strg } fn frst_word(strg: \u0026amp;String) -\u0026gt; usize { let bytes = strg.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return i; } } strg.len() } // fn frst_word_s(strg: \u0026amp;String) -\u0026gt; \u0026amp;str { // let bytes = strg.as_bytes();  // for (i, \u0026amp;item) in bytes.iter().enumerate() { // if item == b\u0026#39; \u0026#39; { // return \u0026amp;strg[0..i]; // } // } // \u0026amp;strg[..] // }  fn frst_word_s(strg: \u0026amp;str) -\u0026gt; \u0026amp;str { let bytes = strg.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return \u0026amp;strg[0..i]; } } \u0026amp;strg[..] }     Using Structs #   struct / function ...  struct User { name: String, mail: String, sign: u64, actv: bool, } fn add_user(mail: String, name: String) -\u0026gt; User { User { name, mail, sign: 1, actv: true, } } struct Color(i32, i32, i32); struct Point(i32, i32, i32); // Struct with reference (Lifetimes) // struct UserLife { // name: \u0026amp;str, // expected named lifetime parameter // mail: \u0026amp;str, // expected named lifetime parameter // sign: u64, // actv: bool, // }  // struct 1 fn area1(leng: u32, wdth: u32) -\u0026gt; u32 { leng * wdth } // struct 2 fn area2(dims: (u32, u32)) -\u0026gt; u32 { dims.0 * dims.1 } #[derive(Debug)] // struct 3 struct Rect { leng: u32, wdth: u32, } fn area3(rect: \u0026amp;Rect) -\u0026gt; u32 { rect.leng * rect.wdth } #[derive(Debug)] // struct 4 struct Rectangle { length: u32, width: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.length * self.width } fn hold(\u0026amp;self, othr: \u0026amp;Rectangle) -\u0026gt; bool { self.length \u0026gt; othr.length \u0026amp;\u0026amp; self.width \u0026gt; othr.width } fn sqre(size: u32) -\u0026gt; Rectangle { Rectangle { length: size, width: size, } } } fn main() { // struct  let user1 = User { name: String::from(\u0026#34;Jake\u0026#34;), mail: String::from(\u0026#34;admin@abc.com\u0026#34;), sign: 1, actv: true, }; let user2 = User { name: String::from(\u0026#34;Hans\u0026#34;), mail: String::from(\u0026#34;aaa@abc.com\u0026#34;), sign: user1.sign, actv: user1.actv, }; let user3 = User { name: String::from(\u0026#34;Dale\u0026#34;), mail: String::from(\u0026#34;aaa@abc.com\u0026#34;), ..user1 }; // tuple  println!(\u0026#34;{}\u0026#34;, user1.name); println!(\u0026#34;{}\u0026#34;, user2.name); println!(\u0026#34;{}\u0026#34;, user3.name); let blck = Color(0, 0, 0); let orgn = Point(0, 0, 0); // // struct with reference  // let user1 = User {  // name: String::from(\u0026#34;Jake\u0026#34;),  // mail: String::from(\u0026#34;admin@abc.com\u0026#34;),  // sign: 1,  // actv: true,  // };  let leng = 50; let wdth = 30; println!(\u0026#34;{}\u0026#34;, area1(leng, wdth)); let rect1 = (50, 30); println!(\u0026#34;{}\u0026#34;, area2(rect1)); let rect2 = Rect { leng: 50, wdth: 30 }; println!(\u0026#34;{}\u0026#34;, area3(\u0026amp;rect2)); // derive(Debug)  println!(\u0026#34;rect is {:?}\u0026#34;, rect2); // struct implementation  let rect3 = Rectangle { length: 50, width: 30, }; println!(\u0026#34;{:?},{}\u0026#34;, rect3, rect3.area()); let rect4 = Rectangle { length: 50, width: 30, }; let rect5 = Rectangle { length: 40, width: 10, }; let rect6 = Rectangle { length: 45, width: 60, }; println!(\u0026#34;rect4 hold rect5 {}\u0026#34;, rect4.hold(\u0026amp;rect5)); println!(\u0026#34;rect4 hold rect6 {}\u0026#34;, rect4.hold(\u0026amp;rect6)); // associated functions  let sqre = Rectangle::sqre(3); println!(\u0026#34;sqre : {:?}\u0026#34;, sqre) }     Enums and Pattern Matching #   enums ...  #[derive(Debug)] enum IpAddrKind { V4, V6, } #[derive(Debug)] struct IpAddr { kind: IpAddrKind, addr: String, } #[derive(Debug)] enum IpAddrStr { V4(String), V6(String), } #[derive(Debug)] enum IpAddrU8 { V4(u8, u8, u8, u8), V6(String), } #[derive(Debug)] enum IpAddrStrc { V4(Ipv4Addr), V6(Ipv6Addr), } #[derive(Debug)] struct Ipv4Addr { addr: String, } #[derive(Debug)] struct Ipv6Addr { addr: String, } fn route(ip_type: IpAddrKind) { println!(\u0026#34;{:?}\u0026#34;, ip_type) } #[derive(Debug)] enum Mssg { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), } impl Mssg { fn call(\u0026amp;self) { println!(\u0026#34;Mssg::call\u0026#34;) } } struct QuitMessage; struct MoveMessage { x: i32, y: i32, } struct WriteMessage(String); struct ChangeColorMessage(i32, i32, i32); enum Optn\u0026lt;T\u0026gt; { Some(T), None, } fn main() { // enum 1  let ip4 = IpAddrKind::V4; let ip6 = IpAddrKind::V6; route(IpAddrKind::V4); route(IpAddrKind::V6); route(ip4); route(ip6); // enum 2  let home = IpAddr { kind: IpAddrKind::V4, addr: String::from(\u0026#34;127.0.0.1\u0026#34;), }; let lbck = IpAddr { kind: IpAddrKind::V6, addr: String::from(\u0026#34;::1\u0026#34;), }; println!(\u0026#34;{:?}\u0026#34;, home); println!(\u0026#34;{:?}\u0026#34;, lbck); // enum 3  let home = IpAddrStr::V4(String::from(\u0026#34;127.0.0.1\u0026#34;)); let lbck = IpAddrStr::V6(String::from(\u0026#34;::1\u0026#34;)); println!(\u0026#34;{:?}\u0026#34;, home); println!(\u0026#34;{:?}\u0026#34;, lbck); // enum 4  let home = IpAddrU8::V4(127, 0, 0, 1); let lbck = IpAddrU8::V6(String::from(\u0026#34;::1\u0026#34;)); println!(\u0026#34;{:?}\u0026#34;, home); println!(\u0026#34;{:?}\u0026#34;, lbck); // enum 5  let home = IpAddrStrc::V4(Ipv4Addr { addr: String::from(\u0026#34;127.0.0.1\u0026#34;), }); let lbck = IpAddrStrc::V6(Ipv6Addr { addr: String::from(\u0026#34;::1\u0026#34;), }); println!(\u0026#34;{:?}\u0026#34;, home); println!(\u0026#34;{:?}\u0026#34;, lbck); // enum 6  let mssg = Mssg::Write(String::from(\u0026#34;Hello\u0026#34;)); mssg.call(); // enum 7  let numb = Some(5); let strg = Some(\u0026#34;A string\u0026#34;); let abst: Option\u0026lt;i32\u0026gt; = None; println!(\u0026#34;{:?}\u0026#34;, numb); println!(\u0026#34;{:?}\u0026#34;, strg); println!(\u0026#34;{:?}\u0026#34;, abst); }      match ...  #[derive(Debug)] enum UsState { Alabama, Alaska, } enum Coin { Penny, Nickel, Dime, Quater(UsState), } fn value_in_cents(coin: Coin) -\u0026gt; u32 { // enum \u0026amp; match  match coin { Coin::Penny =\u0026gt; { println!(\u0026#34;Lucky penny!\u0026#34;); 1 } Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quater(state) =\u0026gt; { println!(\u0026#34;State quater from {:?}!\u0026#34;, state); 25 } } } fn plus_one(x: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; { match x { None =\u0026gt; None, Some(i) =\u0026gt; Some(i + 1), } } fn main() { // enum 1  let coin1 = Coin::Penny; println!(\u0026#34;{}\u0026#34;, value_in_cents(coin1)); // enum2  let coin2 = Coin::Quater(UsState::Alaska); println!(\u0026#34;{}\u0026#34;, value_in_cents(coin2)); // Option\u0026lt;T\u0026gt; Matching  let five = Some(5); let six = plus_one(five); let none = plus_one(None); println!(\u0026#34;{:?}\u0026#34;, five); println!(\u0026#34;{:?}\u0026#34;, six); println!(\u0026#34;{:?}\u0026#34;, none); // Placeholder  let some_u8_value = 0u8; match some_u8_value { 1 =\u0026gt; println!(\u0026#34;one\u0026#34;), 3 =\u0026gt; println!(\u0026#34;three\u0026#34;), 5 =\u0026gt; println!(\u0026#34;five\u0026#34;), 6 =\u0026gt; println!(\u0026#34;seven\u0026#34;), 7 =\u0026gt; (), _ =\u0026gt; println!(\u0026#34;???\u0026#34;), } let some_u8_value = Some(3); // before if let  match some_u8_value { Some(3) =\u0026gt; println!(\u0026#34;three\u0026#34;), _ =\u0026gt; (), } // after if let (syntax sugar)  if let Some(3) = some_u8_value { println!(\u0026#34;Three\u0026#34;); } // let mut / if let else  let coin2 = Coin::Quater(UsState::Alaska); let mut count = 0; match coin2 { Coin::Quater(state) =\u0026gt; println!(\u0026#34;State {:?}\u0026#34;, state), _ =\u0026gt; count += 1, } let coin2 = Coin::Quater(UsState::Alabama); if let Coin::Quater(state) = coin2 { println!(\u0026#34;State {:?}\u0026#34;, state); } else { count += 1; } }     Mods #   mods ...  main.rs\nextern crate rust_comm; pub mod a { pub mod sers { pub mod of { pub fn nest_mods() {} } } } use a::sers::of; use a::sers::of::nest_mods; enum TrffLight { Red, Yellow, Green, } // use green은 제외 // use TrffLight::{Red, Yellow}; // use에서 전체 포함 use TrffLight::*; fn main() { rust_comm::client::connect(); // importing names \ta::sers::of::nest_mods(); // use short type \tof::nest_mods(); // use short type \tnest_mods(); let red = Red; let yellow = Yellow; //let green1 = TrffLight::Green; \tlet green2 = Green; } lib.rs\n// rust_comm // ⨽ network // ⨽ client // // network::connect() // mod network { // fn connect() { // } // }  // // client::connect() // mod client { // fn connect() { // } // }  // rust_comm // ⨽ network // ⨽ client // network::connect // network::client::connect // mod network { // fn connect() {} // mod client { // fn connect() {} // } // }  // rust_comm // ⨽ client // ⨽ network // ⨽ server // client // mod client { // fn connect() { // } // } // // network // // network::server // mod network { // fn connect() { // } // mod server { // fn connect() { // } // } // }  // src/client.rs pub mod client; // src/networ.rs pub mod network; // src/network/client2.rs // pub mod client2;  mod outm { pub fn midd_func() {} pub fn midd_scrt_func() {} pub mod insd { pub fn innr_func() {} pub fn scrt_func() {} } } fn try_me() { outm::midd_func(); outm::midd_scrt_func(); outm::insd::innr_func(); outm::insd::scrt_func(); } #[cfg(test)] mod tests { use super::client2; #[test] fn it_works() { assert_eq!(2 + 2, 4); // client2::connect();  client2::connect(); } } client.rs\npub fn connect() {} \\network\\mod.rs\npub fn connect() {} mod server; \\network\\server.rs\nfn connect() {} \\network\\client2.rs\npub fn connect2() {}     Collections #   vectors ...  #[derive(Debug)] enum SpreadsheetCell { Int(i32), Float(f64), Text(String), } fn main() { // generic  let v1: Vec\u0026lt;i32\u0026gt; = Vec::new(); let v1 = vec![1, 2, 3]; println!(\u0026#34;{:?}\u0026#34;, v1); // push  let mut v1 = Vec::new(); v1.push(5); v1.push(6); v1.push(7); v1.push(8); println!(\u0026#34;{:?}\u0026#34;, v1); // vector scope  { let v2 = vec![1, 2, 3, 4]; println!(\u0026#34;{:?}\u0026#34;, v2); } // println!(\u0026#34;{:?}\u0026#34;, v2);  // get  let v3 = vec![1, 2, 3, 4, 5]; let third: \u0026amp;i32 = \u0026amp;v3[2]; let fourth: Option\u0026lt;\u0026amp;i32\u0026gt; = v3.get(3); let sixth: Option\u0026lt;\u0026amp;i32\u0026gt; = v3.get(5); println!(\u0026#34;{:?},{:?},{:?}\u0026#34;, third, fourth, sixth); // Vecto Push (???)  let mut v4 = vec![1, 2, 3, 4, 5]; let second = \u0026amp;v4[1]; v4.push(6); println!(\u0026#34;{:?}\u0026#34;, v4); // Vector + for  let v5 = vec![10, 3, 2, 5, 7]; for i in \u0026amp;v5 { println!(\u0026#34;{}\u0026#34;, i); } println!(\u0026#34;{:?}\u0026#34;, v5); // Vector + for  let mut v5 = vec![10, 3, 2, 5, 7]; for i in \u0026amp;mut v5 { *i += 50; println!(\u0026#34;{}\u0026#34;, i); } println!(\u0026#34;{:?}\u0026#34;, v5); // enum  let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\u0026#34;Blue\u0026#34;)), SpreadsheetCell::Float(10.12), ]; println!(\u0026#34;{:?}\u0026#34;, row); }      string ...  fn main() { // str1  let mut str1 = String::new(); let str1 = \u0026#34;hello there?\u0026#34;; // str2  let dat1 = \u0026#34;initial contents\u0026#34;; let str2 = dat1.to_string(); let str2 = \u0026#34;initial contents\u0026#34;.to_string(); // str3  let str3 = String::from(\u0026#34;This is Pen\u0026#34;); println!(\u0026#34;{} , {} , {}\u0026#34;, str1, str2, str3); // str utf8  let hello = String::from(\u0026#34;السلام عليكم\u0026#34;); let hello = String::from(\u0026#34;Dobrý den\u0026#34;); let hello = String::from(\u0026#34;Hello\u0026#34;); let hello = String::from(\u0026#34;שָׁלוֹם\u0026#34;); let hello = String::from(\u0026#34;नमस्ते\u0026#34;); let hello = String::from(\u0026#34;こんにちは\u0026#34;); let hello = String::from(\u0026#34;안녕하세요\u0026#34;); let hello = String::from(\u0026#34;你好\u0026#34;); let hello = String::from(\u0026#34;Olá\u0026#34;); let hello = String::from(\u0026#34;Здравствуйте\u0026#34;); let hello = String::from(\u0026#34;Hola\u0026#34;); println!(\u0026#34;{}\u0026#34;, hello); // push  let mut str4 = String::from(\u0026#34;foo\u0026#34;); str4.push_str(\u0026#34;bar\u0026#34;); str4.push_str(\u0026#34;quz\u0026#34;); println!(\u0026#34;{}\u0026#34;, str4); // push_str : ownership  let mut str5 = String::from(\u0026#34;foo\u0026#34;); let str6 = \u0026#34;bar\u0026#34;; str5.push_str(\u0026amp;str6); println!(\u0026#34;{} , {}\u0026#34;, str5, str6); // push (lol)  let mut str7 = String::from(\u0026#34;lo\u0026#34;); str7.push(\u0026#39;l\u0026#39;); println!(\u0026#34;{}\u0026#34;, str7); // combine  let str8 = String::from(\u0026#34;Hello,\u0026#34;); let str9 = String::from(\u0026#34;World!\u0026#34;); // let str10 = str8 + str9; //expected `\u0026amp;str`, found struct `std::string::String`  // add moethod -\u0026gt; fn add(self, s: \u0026amp;str) -\u0026gt; String {}  // \u0026amp;String -\u0026gt; \u0026amp;str : deref coercion  let str10 = str8 + \u0026amp;str9; //println!(\u0026#34;{}\u0026#34;, str8); //value borrowed here after move  println!(\u0026#34;{}\u0026#34;, str9); println!(\u0026#34;{}\u0026#34;, str10); // +  let str11 = String::from(\u0026#34;tic\u0026#34;); let str12 = String::from(\u0026#34;tac\u0026#34;); let str13 = String::from(\u0026#34;toe\u0026#34;); let str14 = str11 + \u0026#34;-\u0026#34; + \u0026amp;str12 + \u0026#34;-\u0026#34; + \u0026amp;str13; // println!(\u0026#34;{}\u0026#34;, str11);  println!(\u0026#34;{}\u0026#34;, str12); println!(\u0026#34;{}\u0026#34;, str13); println!(\u0026#34;{}\u0026#34;, str14); // format!  let str11 = String::from(\u0026#34;tic\u0026#34;); let str15 = format!(\u0026#34;{}-{}-{}\u0026#34;, str11, str12, str13); println!(\u0026#34;{}\u0026#34;, str15); let str16 = String::from(\u0026#34;hello wrold\u0026#34;); //let str17 = str16[3]; //std::string::String` cannot be indexed by  // \u0026#34;Hello\u0026#34; \u0026#34;Здравствуйте\u0026#34; \u0026#34;안녕하십니까\u0026#34; \u0026amp;str16[0] = ???  let str17 = \u0026amp;str16[0..4]; println!(\u0026#34;{}\u0026#34;, str17); // Panic  // let str16 = String::from(\u0026#34;안녕하십니까\u0026#34;);  // let str17 = \u0026amp;str16[0..1];  // println!(\u0026#34;{}\u0026#34;, str17);  // string for  for chr in \u0026#34;안녕하십니까?\u0026#34;.chars() { println!(\u0026#34;{}\u0026#34;, chr); } // string for  for byt in \u0026#34;안녕하십니까?\u0026#34;.bytes() { println!(\u0026#34;{}\u0026#34;, byt); } }      hashmap ...  use std::collections::HashMap; fn main() { // Hash map 1  let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); println!(\u0026#34;{:?}\u0026#34;, scores); // hash map 2  let teams = vec![String::from(\u0026#34;Blue\u0026#34;), String::from(\u0026#34;Yellow\u0026#34;)]; let init_scores = vec![10, 50]; let score2: HashMap\u0026lt;_, _\u0026gt; = teams.iter().zip(init_scores.iter()).collect(); println!(\u0026#34;{:?}\u0026#34;, score2); let field_nm = String::from(\u0026#34;favorite color\u0026#34;); let field_val = String::from(\u0026#34;Blue\u0026#34;); let mut map = HashMap::new(); map.insert(field_nm, field_val); //println!(\u0026#34;{:?}\u0026#34;, field_nm); // value borrowed here after move  println!(\u0026#34;{:?}\u0026#34;, map); // hash map 3  let team_nm = String::from(\u0026#34;Blue\u0026#34;); let score = scores.get(\u0026amp;team_nm); println!(\u0026#34;{:?}\u0026#34;, score); // hash map for  for (key, value) in \u0026amp;scores { println!(\u0026#34;{}:{}\u0026#34;, key, value); } // hashmap insert  scores.insert(String::from(\u0026#34;Blue\u0026#34;), 25); // hash map for  for (key, value) in \u0026amp;scores { println!(\u0026#34;{}:{}\u0026#34;, key, value); } // hashmap or insert  scores.entry(String::from(\u0026#34;Red\u0026#34;)).or_insert(15); // hash map for  for (key, value) in \u0026amp;scores { println!(\u0026#34;{}:{}\u0026#34;, key, value); } let text = \u0026#34;Hello World Wonderful World Very Wonderful World And Hello Agin\u0026#34;; let mut map = HashMap::new(); for word in text.split_whitespace() { let count = map.entry(word).or_insert(0); // return \u0026amp;mut V  *count += 1; } println!(\u0026#34;{:?}\u0026#34;, map); }      다음글  "});index.add({'id':13,'href':'/docs/documents/backend/rust/rust02/','title':"Rust Basic 02",'section':"Rust",'content':"Rust Basic2 #   직성중.\n 다음글  "});index.add({'id':14,'href':'/docs/documents/backend/go/go02/','title':"GO Advanced",'section':"Go",'content':"Go Advanced #   Go 활용 정리. 하기 사이트 참조.\n노마드 코더 - 쉽고 빠른 Go 시작하기\nAccount #   account ...  main.go\npackage main import ( \u0026#34;fmt\u0026#34; accounts \u0026#34;./accounts\u0026#34; ) func main() { // newAccount \tacct := accounts.NewAccount(\u0026#34;jhook\u0026#34;) fmt.Println(\u0026#34;01 : \u0026#34;, acct) // Deposit \tacct.Deposit(1000) fmt.Println(\u0026#34;02 : \u0026#34;, acct) // Withdraw O \terr := acct.Withdraw(300) fmt.Println(\u0026#34;03 : \u0026#34;, acct) if err != nil { fmt.Println(err) } // Withdraw X \terr = acct.Withdraw(1100) fmt.Println(\u0026#34;04 : \u0026#34;, acct) if err != nil { fmt.Println(err) } fmt.Println(\u0026#34;05 : \u0026#34;, acct) } accounts/account.go\npackage accounts import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) type Account struct { owner string balance int } func NewAccount(owner string) *Account { account := Account{owner: owner, balance: 0} return \u0026amp;account } func (acct *Account) Deposit(amnt int) { acct.balance += amnt } func (acct *Account) Balance() int { return acct.balance } var errNoMoney = errors.New(\u0026#34;Can\u0026#39;t Withdraw\u0026#34;) func (acct *Account) Withdraw(amnt int) error { if acct.balance \u0026lt; amnt { return errNoMoney } acct.balance -= amnt return nil } func (acct *Account) ChangeOwner(nOwnr string) { acct.owner = nOwnr } func (acct *Account) Owner() string { return acct.owner } func (acct *Account) String() string { return fmt.Sprint(acct.Owner(), \u0026#34;\u0026#39;s account. Has:\u0026#34;, acct.Balance()) }     My Dict #   mydict ...  main.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;./mydict\u0026#34; ) func main() { dictionary := mydict.Dictionary{\u0026#34;first\u0026#34;: \u0026#34;First word\u0026#34;} definition1, err1 := dictionary.Search(\u0026#34;second\u0026#34;) if err1 != nil { fmt.Println(err1) } else { fmt.Println(definition1) } definition2, err2 := dictionary.Search(\u0026#34;first\u0026#34;) if err2 != nil { fmt.Println(err2) } else { fmt.Println(definition2) } dictionary.Add(\u0026#34;second\u0026#34;, \u0026#34;Second word\u0026#34;) definition1, err1 = dictionary.Search(\u0026#34;second\u0026#34;) if err1 != nil { fmt.Println(err1) } else { fmt.Println(definition1) } dictionary.Add(\u0026#34;third\u0026#34;, \u0026#34;Third word\u0026#34;) definition1, err1 = dictionary.Search(\u0026#34;third\u0026#34;) if err1 != nil { fmt.Println(err1) } else { fmt.Println(definition1) } } mydict/mydict.go\npackage mydict import \u0026#34;errors\u0026#34; type Dictionary map[string]string var errNotFound = errors.New(\u0026#34;Not Found\u0026#34;) var errWordExists = errors.New(\u0026#34;Word Exists\u0026#34;) func (d Dictionary) Search(word string) (string, error) { value, exists := d[word] if exists { return value, nil } return \u0026#34;\u0026#34;, errNotFound } func (d Dictionary) Add(word, def string) error { _, err := d.Search(word) switch err { case errNotFound: d[word] = def case nil: return errWordExists } return nil }      다음글  "});index.add({'id':15,'href':'/docs/documents/devops/','title':"Dev ops",'section':"Documents",'content':"Dev ops #     Oracle   Description   Synology   Description   Ubuntu   Description   Docker   Description   AWS   Description   "});index.add({'id':16,'href':'/docs/documents/deeplearning/','title':"Deep Learning",'section':"Documents",'content':"Deep Learning #     Machine Learning   머신러닝/딥러닝 학습 자료   Tensorflow   Description   "});index.add({'id':17,'href':'/docs/documents/deeplearning/machinelearning/','title':"Machine Learning",'section':"Deep Learning",'content':"Machine Learning #   머신 러닝 관련 자료 정리\nMachine Learning 분류 #  머신 러닝은 지도학습, 비지도학습, 강화학습으로 분류. 지도학습은 다시 회귀와 분류, 비지도 학습은 군집화,변환,연관으로 분류1.\n Supervised Learning  Regression Classification   Unsupervised Learning  Clustering Transform Association   Reinforcement Learning  Linear Regression2 #  Regression이란 전체의 평균으로 회귀하려는 속성을 나타냄. 데이터의 분포를 가장 잘 설명 할 수 있는 직선의 방정식을 찾아내는 것을 의미.\n  --  linear regression ...   H(X) = WX+B ( y = ax + b ) H : Hypothesis (가설) W : Weight (기울기) B : Bias (절변)     Cost는 데이터와 직선 차이의 합. 음수, 양수 모두 존재함으로 제곱을 사용.\n  --  cost ...   Cost :   \\( H(x) - y \\)  Total Cost :  \\( \\frac{(H(x_1)-y_1)^2 \u0026#43; (H(x_2)-y_2)^2 \u0026#43; ... \u0026#43; (H(x_n)-y_n)^2 }{n} \\)  Total Cost : cost(W) =  \\( \\frac{1}{n}\\, \\textstyle\\sum_{i=1}^n \\,(Wx_i-y)^2 \\)  Cost Function : cost(W,b) =  \\( \\frac{1}{n}\\, \\textstyle\\sum_{i=1}^n \\,(H(x_i)-y_i)^2 \\)  Goal : minimize_w,_b cost(W,b)     Goal은 가설과 실제 데이터 차이의 제곱이 최소가 되는 기울기와 절편은 찾는 문제.\nGradient Descent #  임의 점에서 시작 학습률 만큼 기울기가 낮은 쪽으로 진행하며 최적해를 탐색하는 방식을 경사하강법이라 함. Convext 상황에서는 잘 작동하나 Local Optimal이 존재할 경우 문제가 발생됨3.\n  --  gradient descent ...    \\( W := W - \\alpha \\frac{\\partial}{\\partial W} \\, \\frac{1}{2m} \\textstyle\\sum_{i=1}^m (W(x_i)-y_i)^2 \\)   \\( W := W - \\alpha \\frac{1}{2m} \\, \\textstyle\\sum_{i=1}^m 2(W(x_i)-y_i)X_i \\)   \\( W := W - \\alpha \\frac{1}{m} \\, \\textstyle\\sum_{i=1}^m (W(x_i)-y_i)X_i \\)   \\( W := W - \\alpha \\frac{\\partial}{\\partial W} \\, cost(W) \\)      Derivative #  함수 f(x)에 대한 미분은 아래와 같음. x의 변화량이 0으로 수렴할때 y의 변화량을 의미.\n derivative ...    \\( f\u0026#39;(x) = \\frac{\\Delta f(x)}{\\Delta x} = \\lim\\limits_{\\Delta x \\rightarrow 0 } \\, \\frac{f(x\u0026#43;\\Delta x)-f(x)}{\\Delta x} \\)      미분 기초 정리\n derivative basic ...    \\( f(x) = constant -\u0026gt; f\u0026#39;(x) = 0 \\)   \\( f\u0026#39;(x) = e ^ x =\u0026gt; f\u0026#39;(x) = e ^ x \\)   \\( f\u0026#39;(x) = e ^ -x =\u0026gt; f\u0026#39;(x) = -e ^ -x \\)   \\( f\u0026#39;(x) = ax ^ x =\u0026gt; f\u0026#39;(x) = nax ^ {n-1} \\)   \\( f\u0026#39;(x) = ln ^ x =\u0026gt; f\u0026#39;(x) = \\frac{1}{x} \\)   \\( \\frac{1}{x} = x^{-1} \\)      미분의 의미\n  meaning of derivative ...    \\( f(x) = x^2 \\)  일 경우  \\( f\u0026#39;(x) = 2 * x^ {2-1} = 2x \\)   \\( f(2) = 2^2 = 4 \\)  일 경우  \\( f\u0026#39;(2) = 2*2 = 4 \\)   \\( f(2) = 1^2 = 1 \\)  일 경우  \\( f\u0026#39;(2) = 2*1 = 2 \\)   \\( f(2) = 0^2 = 0 \\)  일 경우  \\( f\u0026#39;(2) = 2*0 = 0 \\)      즉 x = 2 일때 미분 f(x)는 4의 변화를 가지게 됨 즉 x = 1 일때 미분 f(x)는 2의 변화를 가지게 됨 즉 x = 0 일때 미분 f(x)는 0의 변화를 가지게 됨 즉 x의 한점에서 y의 변화량을 통해 위의 x^2이 Cost라 가정하고 반복한다면 기울기가 0이되는 즉 Cost가 최저인 점을 구할 수 있음.\n practice 1 : derivative ...    \\( f(x) = 3x^2 \u0026#43; e^x \u0026#43; 7 \\)  의  \\( f\u0026#39;(x) ? \\)   \\( = 3*2*x^{2-1} \u0026#43; e^x \u0026#43; 0 = 6x \u0026#43; e^x \\)       practice 2 : derivative ...    \\( f(x) = lnx \u0026#43; \\frac{1}{x} \\)  의  \\( f\u0026#39;(x) ? \\)    \\( = \\frac{1}{x} - \\frac{1}{x^2} \\)      입력변수가 하나 이상인 다변수 함수에서 사용하는 편미분을 사용. 편미분은 미분하고자 하는 변수를 제외하고 나머지는 상수로 취급.\n practice 1 : partial derivative ...    \\( f(x,y) = 2x \u0026#43; 3xy \u0026#43; y^3 \\)  변수 x에 대해 편미분  \\( = \\frac{\\partial f(x,y)}{\\partial x} = \\frac{\\partial(2x\u0026#43;3xy\u0026#43;y^3)}{\\partial x} \\)   \\( = \\frac{\\partial 2x}{\\partial x} \u0026#43; \\frac{\\partial 3xy}{\\partial x} \u0026#43; \\frac{\\partial y^3}{\\partial x} \\)   \\( = 2 \u0026#43; 3y \u0026#43; 0 \\)   \\( = 2 \u0026#43; 3y \\)   \\( f(x,y) = 2x \u0026#43; 3xy \u0026#43; y^3 \\)  변수 y에 대해 편미분  \\( = \\frac{\\partial f(x,y)}{\\partial y} = \\frac{\\partial(2x\u0026#43;3xy\u0026#43;y^3)}{\\partial y} \\)   \\( = \\frac{\\partial 2x}{\\partial y} \u0026#43; \\frac{\\partial 3xy}{\\partial y} \u0026#43; \\frac{\\partial y^3}{\\partial y} \\)   \\( = 0 \u0026#43; 3x \u0026#43; 3y^2 \\)   \\( = 3x \u0026#43; 3y^2 \\)      복합 함수를 위해 Chain Rule을 통해 미분. 특정 함수를 치환하여 약분 개념을 적용. 두 함수 곱의 미분은 단순 곱이 아니며 Product Rule이 적용됨.\n  chain rule ...    \\( \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial t} \\circ \\frac{\\partial t}{\\partial x} \\)       product rule ...    \\( \\frac{\\partial}{\\partial x}[f(x)g(x)]=f(x)g\u0026#39;(x)\u0026#43;f\u0026#39;(x)g(x) \\)       practice 1 : chain rule ...    \\( f(x) = e ^ {3x^2} \\space \\space \\space e^t , \\space t = 3x^2 \\)   \\( \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial t} \\circ \\frac{\\partial t}{\\partial x} = \\frac{\\partial (e^t)}{\\partial t} \\circ \\frac{\\partial (3x^2)}{\\partial x} = (e^t)(6x) = (e^{3x^2})(6x) = 6xe^{3x2} \\)       practice 2 : chain rule ...    \\( f(x) = e^{-x} \\space \\space \\space e^t , \\space t = -x \\)   \\( \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial t} \\circ \\frac{\\partial t}{\\partial x} = \\frac{\\partial (e^t)}{\\partial t} \\circ \\frac{\\partial (-x)}{\\partial x} = (e^t)(-1) = (e^{-x})(-1) = -e^{-x} \\)       practice 3 : chain/product rule ...    \\( f(x) = 3xe^x \\)   \\( \\frac{\\partial}{\\partial x}(3xe^x) = 3 \\Big( \\frac{\\partial}{\\partial x}(e^x x) \\Big) \\)  Product Rule을 적용  \\( \\frac{\\partial}{\\partial x}(u v) = v \\frac{\\partial u}{\\partial x} \u0026#43; u \\frac{\\partial v}{\\partial x} \\)  다음으로 치환  \\( u = e^x \\space v = x \\)   \\( 3 \\Big( x \\frac{\\partial}{\\partial x}(e^x) \u0026#43; e^x \\frac {\\partial}{\\partial x}(x) \\Big) \\)  Chain Rule을 적용  \\( \\frac{\\partial}{\\partial x}(e^x) = \\frac {\\partial e^u}{\\partial u} \\frac{\\partial u}{\\partial x} \\)  다음으로 치환  \\( u = x, \\space \\frac{\\partial}{\\partial u}(e^u)=e^u \\)   \\( = 3 \\Big( x e^x \\frac{\\partial}{\\partial x}(x) \u0026#43; e^x \\frac{\\partial}{\\partial x}(x) \\Big) \\)   \\( = 3 \\Big( x e^x 1 \u0026#43; e^x \\frac{\\partial}{\\partial x}(x) \\Big) \\)   \\( = 3 \\Big( x e^x \u0026#43; e^x 1 \\Big) \\)   \\( = 3 ( x e^x \u0026#43; e^x ) \\)   \\( = 3 e^x( x \u0026#43; 1 ) \\)      Loss Function #  다시 선형회귀에서 실측되는 데이터와 f(x) = wx+b간 error는 최소가 되어야함. Error가 최소가 되는 W,B를 연속적으로 측정하기 위해 사용되는 것이 손실함수임.\n  loss function ...    \\( Loss Funtion = \\frac{(t_1-y_1)^2 \u0026#43; (t_2-y_2)^2 \u0026#43; ... \u0026#43; (t_n-y_n)^2}{n} \\)   \\( = \\frac{[t_1-(Wx_1\u0026#43;b)]^2 \u0026#43; [t_2-(Wx_2\u0026#43;b)]^2 \u0026#43; ... \u0026#43; [t_n-(Wx_n\u0026#43;b)]^2}{n} \\)   \\( = \\frac{1}{n} \\, \\displaystyle\\sum_{i=1}^n \\, [t_i-(Wx_i\u0026#43;b)]^2 \\)       원 기울기에서 학습률*미분만큼을 감소시키며 기울기가 0이 되는 최적해로 진행됨.\n gradient descent ...    \\( W := W - \\alpha \\frac{\\partial}{\\partial W} \\, \\frac{1}{2m} \\textstyle\\sum_{i=1}^m (W(x_i)-y_i)^2 \\)   \\( W := W - \\alpha \\frac{1}{2m} \\, \\textstyle\\sum_{i=1}^m 2(W(x_i)-y_i)X_i \\)   \\( W := W - \\alpha \\frac{1}{m} \\, \\textstyle\\sum_{i=1}^m (W(x_i)-y_i)X_i \\)   \\( W := W - \\alpha \\frac{\\partial}{\\partial W} \\, cost(W) \\)   \\( b := b - \\alpha \\frac{\\partial}{\\partial b} \\, cost(b) \\)      여기서 학습률은 최적해를 향한 진행 폭을 결정. 작을 경우 성능이 저하. 클 경우 학습이 진행되지 않음.\n  learning rate ...    \\( W = W - \\alpha \\, \\frac{\\partial E(W,b)}{\\partial W} \\)       이론적으로 Convex Function이라면 대체로 최적해를 잘 찾을 수 있으나 그렇지 않다면 Parameter에 따라 결과가 상이할 수 있음.\n Dot Product #  모든 요소들의 행렬곱을 통해 계산.\n  dot product ...    \\( x_1 * W \u0026#43; b_1 = y_1 \\)   \\( x_2 * W \u0026#43; b_2 = y_2 \\)   \\( x_3 * W \u0026#43; b_3 = y_3 \\)   \\( x_4 * W \u0026#43; b_4 = y_4 \\)   \\( x_5 * W \u0026#43; b_5 = y_5 \\)  행렬의 곱으로 전환  \\( \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ x_5 \\end{pmatrix} \\circ (W) \u0026#43; b = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ y_3 \\\\ y_4 \\\\ y_5 \\end{pmatrix} \\)   \\( X \\circ W \u0026#43; b = Y \\)       multi variable dot product ...    \\( \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ x_5 \\end{pmatrix} \\circ \\begin{pmatrix} w_1 \\\\ w_2 \\\\ w_3 \\end{pmatrix} \u0026#43; b = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ y_3 \\\\ y_4 \\\\ y_5 \\end{pmatrix} \\)   \\( X \\circ W \u0026#43; b = Y \\)      Logistic Regression #  Regression을 통해 처리된 결과를 Classification 처리함. Linear Regression의 결과는 수치형 값을 가지게 됨으로 분류 문제에 취약. Linear한 결과를 Logistic Regression을 통해 선택의 결과로 대치.\n 분류의 문제를 위해 지수 함수  \\( e^x \\)  를  \\( e^{-x} \\)  로 전환 후  \\( \\frac{1}{1 \u0026#43; e^{-x}} \\)  에 대입하여 x의 좌측으로 진행할수로  \\( \\infty \\)  에 가까워지며 0에 수렴하게되고 x의 우측으로 진행하게 될수록 0에 수렴하면서 1에 가까워지는 결과가 됨.\n   sigmoid ...    \\( Z = Wx \u0026#43; b \\)   \\( y = \\frac {1}{1\u0026#43;e^{-(Wx\u0026#43;b)}} \\)   \\( y = sigmoid(Z) = \\sigma (z) = \\frac{1}{1\u0026#43;e^{-z}} \\)      Logistic Regression의 Cost Function은 y = 1 일때와 y = 0 일때로 구분할 수 있는데 y = 1 일때는  \\( \\log(h(x)) \\)  의 역  \\( -\\log(h(x)) \\)  을 취해 0으로 근접할 수록 오차가  \\( \\infty \\)  에 수렴하게 됨. 반대로 y = 0 일때는  \\( \\log(1 - h(x)) \\)  와 같이 1에서 차감하여 1에 근접할 수록 오차가  \\( \\infty \\)  에 수렴하함. 이 두 식을 합하면 Logistic Regression의 Convex한 Cost Funtion이 되게 됨.\n  Cross-Entropy 유도의 또다른 설명은 다음과 같음.\n하나의 입력 x에 대해 출력이 1일 확률을 y로 정의. y는 0 또는 1일임으로 y = sigmoid(Wx+b)로 나타낼 수 있음. 입력 x에 대해 출력이 0일 확률은 1이 나타날 확률의 나머지임으로 1-y 임. 확률 변수 C는 0 또는 1 이외에는 존재하지 않음으로 베르누이 시행을 전제로 하며 베르누이 분포의 확률질량함수(PMF)는 아래와 같이 정의됨. 이를 Log 변환을 통해 Convex의 형태와 극점의 위치를 유지하며 곱을 선형의 조합 꼴로 풀 수 있도록 변환함.\n bernoulli distribution (PMF) ...    \\( p(C=1|x) = y = sigmoid(Wx\u0026#43;b) \\)   \\( p(C=0|x) = 1 - p(C=1|x) = 1 - y \\)   \\( p(C=p|x) = y^p ( 1 - y )^{1-P} \\)   \\( Likelyhood (W,b) = \\displaystyle\\prod_{i=1}^n p(C=p_i|x_i) = \\displaystyle\\prod_{i=1}^n y_i^{p_i} (1-y_i)^{1-p_i} \\)   \\( E(W,b) = - \\log L(W,b) = -\\displaystyle\\sum_{i=1}^n \\lbrace t_i \\textstyle\\log y_i \u0026#43; (1-p_i) \\log(1-y_i) \\rbrace \\)       logistic regression cross entropy ...    \\( y = \\frac{1}{1\u0026#43;e^{-(Wx\u0026#43;b)}} , \\space p_i = 0 \\space or \\space 1 \\)   \\( E(W,b) = - \\, \\displaystyle\\sum_{i=1}^n \\, \\lbrace p_i \\, \\log y_i \u0026#43; (1-p_i) \\log (1-y_i) \\rbrace \\)      Bayes Theorem #  Logit, Sigmoid, Softmax를 유도하기 위해 다음과 같은 확률의 개념이 선행되어야함.\n 베이지안 예제 몬티홀문제 베이즈의 정리  불확실성 하의 의사 결정의 문제를 수학적으로 다룰때 사용되는 베이즈의 정리(Bayes Theorem)와 전확률 법칙(law of total probability)는 다음과 같음.\n bayes theorem ...    \\( P(Y|X) = \\frac {P(X \\bigcap Y)}{P(X)} \\)   \\( P(X|Y) = \\frac {P(Y \\bigcap X)}{P(Y)} \\)   \\( P(Y \\bigcap X) = P(X \\bigcap Y) = P(X|Y)P(Y) = P(Y|X)P(X) \\)   \\( \\therefore P(Y|X) = \\frac {P(X|Y)P(Y)}{P(X)} \\)  P(Y|X) : 사후확률(Posterio probability)\nP(X|Y) : 가능도(likelihood)\nP(Y) : 확률변수 Y의 사전확률(prior probability)\nP(X) : 확률변수 X의 사전확률(prior probability)\n    표본 공간 S를 n개로 나누었을때 사건 A의 확률은 다음과 같이 나타나며 총합은 1이됨.\n law of total probability ...    \\( P(A) = P(A \\bigcap B_1) \u0026#43; P(A \\bigcap B_2) \u0026#43; ... \u0026#43; P(A \\bigcap B_n) \\)      일반적으로  \\( A_1,A_2,A_3 \\)  가 서로 Mutually Exclusive이고 이들의 합집합이 표본공간과 S와 같으면 사건  \\( A_1,A_2,A_3 \\)  는 표본공간 S의 분할이라고 정의. 특정 사건 B가 나타날 확률은 전확률 공식에 의거 다음과 같이 표현할 수 있음.\n b : law of total probability ...    \\( P(B)) = P(A_1)P(B|A_1)\u0026#43; P(A_2)P(B|A_2) \u0026#43; P(A_3)P(B|A_3) = \\displaystyle\\sum_{i=1}^3 P(A_i)P(B|A_i) \\)       \\(P(A_1)\\)  , \\(P(A_2)\\)  , \\(P(A_3)\\)  은 미리 알고 있다는 의미로 사전확률(Prior Probability)로 불리고,  \\(P(B|A_1)\\)  , \\(P(B|A_2)\\)  , \\(P(B|A_3)\\)  는 우도(Likelihood Probability)라 부름.\n \\( P(A_1|B) \\)  는 사건 B를 관측한 후 원인이 되는 사건 A의 확률을 따졌다는 의미에서 사후확률(Posterior Probability)로 정의되며 다음과 같이 나타낼 수 있음.\n posterior probability ...    \\( P(A_1|B)) = \\frac {P(A_1)P(B|A_1)}{P(B)} = \\frac {P(A_1)P(B|A_1)}{P(A_1)P(B|A_1)\u0026#43;P(A_2)P(B|A_2)\u0026#43;P(A_3)P(B|A_3)} \\)       practice 1 : 진단문제 ...   전체 인구의 1%가 어떤 병에 걸렸다고 가정. 이 병의 진단 정확도가 97% 오진률은 6%라고 가정.\n \\( P(D) = 0.01 \\)  : 사전확률  \\( P( \\backsim D) = 0.99 \\)  : 사전확률  \\( P(\u0026#43;|D) = 0.97 \\)  : 우도  \\( P(\u0026#43;| \\backsim D) = 0.06 \\)  : 우도  \\( P(D|\u0026#43;) \\)  = ????? : 사후확률 (진단테스트 양성일때 실제 환자일 확률 )  \\( P(\u0026#43;) = P(D \\cap \u0026#43;)\u0026#43;P( \\backsim D \\cap \u0026#43;) \\)   \\( = P(D)P(\u0026#43;|D)\u0026#43;P( \\backsim D)P(\u0026#43;| \\backsim D) \\)   \\( = 0.01 \\times 0.97 \u0026#43; 0.99 \\times 0.06 \\)   \\( = 0.691 \\)   \\( P(D|\u0026#43;) = \\frac {P(D)P(\u0026#43;|D)}{P(\u0026#43;)} \\)   \\( = \\frac {0.01 \\times 0.97}{0.691} \\)   \\( = 0.014 \\)       practice 2 : 딸기맛 문제 ...   사탕주머니 1 : 딸기맛 30개, 포도맛 10 사탕주머니 2 : 딸기맛 20개, 포도맛 20 두 주머니에서 임의로 골랐을때 딸기였다면 주머니1에서 나왔을 확률은?  \\( P(H) \\)  : 사전확률 - 주머니1을 고를 확률  \\( P(D|H) \\)  : 우도 - 주머니1의 딸기 확률  \\( P(D) \\)  : 한정상수 - 딸기를 고를 확률  \\( P(H|D)) \\)  : 사후확률 - 주머니1에서 딸기를 골랐을 확률  \\( P(H|D)) = \\frac {P(H)P(D|H)}{P(D)} = \\frac { \\frac {1}{2} * \\frac {3}{4} }{ \\frac {5}{8} } = \\frac {3}{5} \\)  이때 한정상수  \\( P(D) \\)  는 상호배제(Mutually Exclusive)와 전체포괄(Collectively Exhaustive)의 원칙에서 같은 값을 지니며 계산이 생략됨\n   Point Theory1 Theory2     사전확률 P(H) 1/2 1/2   우도P(D H) 3/4   사전확률*우도 3/8 1/4   한정상수P(D) 5/8 5/8   사후확률P(H D) 3/5     \\( P(H|D) = \\frac {P(H)P(D|H)}{P(D)} = \\frac { \\frac {1}{2} * \\frac {3}{4} }{ \\frac {5}{8} } = \\frac {3}{5} \\)       practice 3 : 카드문제 ...   카드A : 앞뒤 모두 검은색\n카드B : 앞은 검은색, 뒤는 하얀색\n카드C : 앞뒤 모두 하얀색\n세카드 중 하나를 뽑아서 본면이 검은색일 때 그 뒷면도 검은색이 나올 확률\n \\( P(A|Black) = \\frac {P(A)P(Black|A)}{P(Black)} \\)   \\( = \\frac {P(A)P(Black|A)}{P(A)P(Black|A)\u0026#43;P(B)P(Black|B)} \\)   \\( = \\frac { \\frac {1}{3} * 1 }{ \\frac {1}{3} * 1 \u0026#43; \\frac{1}{3} * \\frac{1}{2} } = \\frac {2}{3} \\)       practice 4 : 몬티홀문제 ...   문A1 : 상금\n문A2 : 꽝\n문A3 : 꽝\n출연자가 문을 하나 선택한 후\n사회자가 다른 문을 열어 문을 하나 보여준 후\n출연자가 선택을 바꾸지 않고 문을 열때의 당첨 확률\n \\( P(A1|B) = \\frac {P(A1 \\cap B))}{P(B)} = \\frac {P(A1 \\cap B)}{P(A1 \\cap B) \u0026#43; P(A2 \\cap B) \u0026#43; P(A3 \\cap B)} = \\frac { P(A1)P(B|A1) }{ P(A1)P(B|A1) \u0026#43; P(A2)P(A2|B) \u0026#43; P(A3)P(A3|B) } = \\frac {\\frac {2}{3} * \\frac {1}{2}}{\\frac {1}{3}* \\frac {1}{2} \u0026#43; \\frac {1}{3}*0 \\frac {1}{3}*1} = \\frac {1}{3} \\)      Logit / Sigmoid / Softmax #  Logit /Sigmoid /Softmax의 관계를 정리\n 참고1 gwkoo.log - Logit,Sigmoid,Softmax의 관계 참고2 한 페이지 머신러닝 Logit,Sigmoid,Softmax의 관계 참고3 ChaCha\u0026rsquo;s blog - Sigmoid, Logit and Softmax 참고4 ratsgo\u0026rsquo;s blog - 베이즈 규칙과 다양한 문제들  Logit은 Log Odds를 의미.\nOdds란 도박에서 얻을 확률과 잃을 확률의 비율을 의미\n odds / logit ...    \\( Classes : C_1, C_2 \\)   \\( Probability of C_1 given X : y = P(C_1|X) \\)   \\( Probability of C_2 given X : 1-y = P(C_2|X) \\)  Odds =  \\( \\frac {y}{1-y} = \\frac {P(C_1|X)}{1-P(C_1|X)} \\)  Choose =  \\( \\begin{cases} C_1 \\space if \\space \\frac {y}{1-y} \u0026gt; 1 \\\\ C_2 \\space if \\space \\frac {y}{1-y} \u0026lt; 1 \\end{cases} \\)      이를 Log를 이용해 0~1의 범위로 한정된 Logit을 도출\n logits ...    \\( = log \\Big( \\frac{y}{1-y} \\Big) \\)   \\( = log \\Big( \\frac{P(C_1|X)}{1-P(C_1|X)} \\Big) \\)   \\( z = log( \\frac {y}{1-y} \\)  ,  \\( e^z = ( \\frac {y}{1-y} ) \\)   \\( e^z = ( \\frac {y}{1-y} ) \\)   \\( \\frac {1}{e^z} = \\frac {1-y}{y} \\)  =  \\( \\frac {1}{e^z} = \\frac {1}{y} -1 \\)   \\( \\frac {1}{e^z} \u0026#43; 1 = \\frac {1}{y} \\)  =  \\( \\frac {1 \u0026#43; e^z}{e^z} = \\frac {1}{y} \\)   \\( \\frac {e^z}{1 \u0026#43; e^z} = y \\)   \\( \\frac {e^z / e^z}{(1 \u0026#43; e^z)/e^z} = y \\)   \\( \\frac {1}{ \\frac{1}{e^z} \u0026#43; 1 } = y \\)   \\( \\frac {1}{ e^{-z} \u0026#43; 1 } = y \\)   \\( \\therefore y = \\frac {1}{ 1 \u0026#43; e^{-z}} \\)      여기서 Softmax는 Sigmoid를 K개 이상으로 일반화 하여 유도.\n softmax ...    \\( \\frac {P(C_1|X)}{P(C_2|X)} = e^z \\)   \\( \\frac {P(C_i|X)}{P(C_k|X)} = e^{z_i} \\)   \\( \\displaystyle\\sum_{i=1}^{k-1} \\frac { P(C_i|X)}{P(C_k|X)} = \\displaystyle\\sum_{i=1}^{k-1} e^{z_i} \\)   \\( \\frac {P(C_1|X)\u0026#43;P(C_2|X)\u0026#43;...\u0026#43;P(C_{k-1}|X)}{P(C_k|X)} = \\displaystyle\\sum_{i=1}^{k-1} e^{z_i} \\)   \\( \\frac {1-P(C_k|X)}{P(C_k|X)} = \\displaystyle\\sum_{i=1}^{k-1} e^{z_i} \\)   \\( P(C_k|X) = \\frac{1}{1\u0026#43; \\textstyle\\sum_{i=1}^{k-1} e^{z_i} } \\)   \\( P(C_i|X) = e^{z_i} P(C_k|X) \\)   \\( P(C_i|X) = \\frac {e^{z_i}}{1 \u0026#43; \\textstyle\\sum_{i=1}^{k-1} e^{z_i}} \\)   \\( P(C_i|X) = \\frac {e^{z_i}}{e^{z_i} \u0026#43; \\textstyle\\sum_{i=1}^{k-1} e^{z_i}} = \\frac {e^{z_i}}{ \\textstyle\\sum_{i=1}^{k} e^{z_i}} \\)      Learning Rate #  Learning Rate와 학습의 상관관계는 아래와 같음. Learning rate가 너무 높을 경우 Overshooting이 발생되며 너무 작을 경우 학습이 매우 더디게 진행됨.\n 학습시점에 따라 Learning rate를 조정하는 decay방식이 있음.\n Step deacy : N epoch or validation loss Exponential decay :  \\( \\alpha = \\apha 0 \\epsilon - kt \\)   1/t decay :  \\( \\alpha = \\apha 0 (1\u0026#43;kt) \\)   inverse time decay natural exponential decay piecewise constant polynomical decay  Data Preprocessing #  Data의 분포가 편중되어 있을 경우 표준화(Standardization)와 정규화(Normalization)을 통해서 전처리.\nFeature Scaling Standardization :  \\( x_{new} = \\frac {x - \\mu}{\\sigma} \\)  Normalization :  \\( x_{new} = \\frac {x - x_{min}}{x_{max} - - x_{min}} \\)  Noisy Data 학습에 필요한 Data로 정제하는 전처리 과정.\nOverfitting #  Underfitting : High bias 상태. 학습이 덜된 상태. Overfitting : High variance. 학습이 너무되어 주어진 data에만 맞춰진 상태.\n Solution\n Set features : Get more training data Set features : Smaller set of features (PCA) Set features : Add additional features (for underfitting) Regularization (Add term to loss)  Linear regression with regularization  softmax ...    \\( h_{\\theta}(x) = \\theta_0 \u0026#43; \\theta_1 x \u0026#43; \\theta_2 x^2 \u0026#43; \\theta_3 x^3 \u0026#43; \\theta_4 x^4 \\)   \\( J(\\theta) = \\frac{1}{2m}\\displaystyle\\sum_{i=1}^m (h_{\\theta}(x^{(i)}) - y^{(i)})^2 \u0026#43; \\frac{ \\lambda }{2m}\\displaystyle\\sum_{j=1}^m \\theta_{j}^2 \\)   \\( \\lambda-- \\)  : fixed high bias (under fitting)  \\( \\lambda\u0026#43;\u0026#43; \\)  : fixed high variance (over fitting)     XOR Prolem #  1958년 Frank Rosenblatt에 의에 제안된 신경망 시스템의 모델로 McGullock, Pitts, Hebb의 연구를 기초로 하고 있음.\n 하지만 XOR의 문제는 Linear Regression으로 해결할 수 없다는 수학적 결론을 내림. (Perceptrons by Marvin Minsky)\n AND    X1 X2 T     0 0 0   1 0 0   0 1 0   1 1 1    OR    X1 X2 T     0 0 0   1 0 1   0 1 1   1 1 1    NAND    X1 X2 T     0 0 1   1 0 1   0 1 1   1 1 0    NOR    X1 X2 T     0 0 1   1 0 0   0 1 0   1 1 0     Flow  mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph LR A(NAND)--C(AND)--D(XOR) B(_OR_)--C style A fill:#ffffff,stroke:#000000,stroke-width:1px style B fill:#ffffff,stroke:#000000,stroke-width:1px style C fill:#ffffff,stroke:#000000,stroke-width:1px style D fill:#ffffff,stroke:#000000,stroke-width:1pxXOR NOR\n   X1 X2 NAND OR AND     0 0 1 0 0   1 0 1 1 1   0 1 1 1 1   1 1 0 1 0     Flow graph LR E(NOR)--F(AND)--G(XOR) H(AND)--F style E fill:#ffffff,stroke:#000000,stroke-width:1px style F fill:#ffffff,stroke:#000000,stroke-width:1px style G fill:#ffffff,stroke:#000000,stroke-width:1px style H fill:#ffffff,stroke:#000000,stroke-width:1pxXOR NOR\n   X1 X2 AND NOR AND     0 0 0 1 0   1 0 0 0 1   0 1 0 0 1   1 1 1 0 0     Backpropagation #  1974, 1982 Paul Werbos, 1986 Hinton에 의해 정립된 개념. 순전파에서 목표값과 모델의 계산값의 오차를 구한후 그 오차값을 역방향으로 전파하며 노드들의 변수들을 갱신하는 알고리즘. 다만 복잡한 Neural Networks 환경에서는 역전파되는 값들이 소실되는 Vanishing Gradient 현상이 발생됨. 2006년 2007년 Hinton과 Bengio에 의해 초기 Parameter에 의한 영향이 주목되며 Deep Learning이라는 용어가 등장함.\nGeoffrey Hinton\u0026rsquo;s summary\n Our labeled datasets were thousands of times too small. Our computers were millions of times too slow. We initialized the wieghts in a stupid way. We used the wrong type of non-linearity.  Node Notation\n  node notation ...    \\( W_{2,1}^{(2)} \\)  : 계층2에 적용되는 가중치로 1계층 노드 1에서 2계층 노드 2로 전달됨을 의미  \\( B_{1}^{(2)} \\)  : 계층2의 노드1에 적용 Bias를 의미  \\( Z_{2}^{(2)} \\)  : 계층2의 노드2의 계산값을 의미 (  \\( Z_{2}^{(2)} = X_1 W_{2,1}^{(2)} \u0026#43; X_2 W_{2,2}^{(2)} \u0026#43; b_2^{(2)} \\)  )  \\( a_{2}^{(2)} \\)  : 계층2의 노드2의 출력값을 의미 (  \\( sigmoid(Z_2^{(2)}) \\)  )     Backpropagation\n Chain Rule을 이용한 국소 미분된 오차 역전파\n derivative of backpropagation ...    \\( W^{(2)} = W^{(2)} - \\alpha \\frac {\\partial E}{\\partial W^{(2)}} = W^{(2)} - \\alpha ( \\frac {\\partial E}{\\partial A^{(3)}} \\cdotp \\frac {\\partial A^{(3)}}{\\partial A^{(2)}} \\cdotp \\frac {\\partial A^{(2)}}{\\partial W^{(2)}} ) \\)      Sigmoid 미분\n derivative of sigmoid ...    \\( \\frac {\\partial sigmoid(z)}{\\partial z} = \\frac {\\partial }{\\partial z} (\\frac {1}{1\u0026#43; e^{-z}} ) \\)  Chian rule 적용 :  \\( \\frac {\\partial f}{\\partial u} \\cdotp \\frac {\\partial u}{\\partial x} \\)  이때  \\( u = e^{-x}\u0026#43;1 \\)  이면  \\( f = \\frac {1}{u} \\)  이고  \\( \\therefore \\frac {\\partial}{\\partial u} (\\frac {1}{u}) \\cdotp \\frac {\\partial u}{\\partial x} \\)   \\( = - \\frac {1}{(1\u0026#43;e^{-x})^2} \\cdotp \\frac {\\partial (1\u0026#43;e^{-x})}{\\partial x} \\)   \\( = - \\frac {1}{(1\u0026#43;e^{-x})^2} \\cdotp (\\frac {\\partial}{\\partial x} (1) \u0026#43; \\frac {\\partial}{\\partial x} (e^{-x})) \\)  Chian rule 적용 :  \\( u = -x \\)  이면  \\( \\frac {\\partial}{\\partial x}(e^{-x}) = \\frac {\\partial e^u}{\\partial u} \\cdotp \\frac {\\partial u}{\\partial x} \\)   \\( \\frac {\\partial}{\\partial u}(e^u) = e^u \\)   \\( \\therefore \\frac {\\partial}{\\partial x}(e^{-x}) = e^{-x} \\)   \\( \\frac {\\partial}{\\partial x}(-x) = -1 \\)   \\( = - \\frac {1}{(1\u0026#43;e^{-x})^2} \\cdotp (\\frac {\\partial}{\\partial x} (1) \u0026#43; \\frac {\\partial}{\\partial x} (e^{-x})) = - \\frac {1}{(1\u0026#43;e^{-x})^2} \\cdotp (0 \u0026#43; -1 e^{-x}) \\)   \\( = \\frac {e^{-x}}{(1\u0026#43;e^{-x})^2} \\)   \\( = \\frac {1\u0026#43;e^{-x}-1}{(1\u0026#43;e^{-x})^2} \\)   \\( = \\frac {1\u0026#43;e^{-x}}{(1\u0026#43;e^{-x})^2} - \\frac {1}{(1\u0026#43;e^{-x})^2} \\)   \\( = \\frac {1}{(1\u0026#43;e^{-x})} - \\frac {1}{(1\u0026#43;e^{-x})^2} \\)   \\( = \\frac {1}{(1\u0026#43;e^{-x})} (1 - \\frac {1}{(1\u0026#43;e^{-x})}) \\)   \\( = sigmoid(x)(1-sigmoid(x)) \\)       using derivative of sigmoid ...    \\( \\frac {\\partial E_{(1)}}{\\partial w_{(1,1)}^{(3)}} = \\frac {\\partial E_{(1)}}{\\partial a_{(1)}^{(3)}} * \\frac {\\partial a_{(1)}^{(3)}}{\\partial z_{(1)}^{(3)}} * \\frac {\\partial z_{(1)}^{(3)}}{\\partial w_{(1,1)}^{(3)}} \\)   \\( = \\frac {\\partial E_{(1)}}{\\partial a_{(1)}^{(3)}} * \\frac {\\partial sigmoid(z_{(1)}^{(3)}}{\\partial z_{(1)}^{(3)}} * \\frac {\\partial z_{(1)}^{(3)}}{\\partial w_{(1,1)}^{(3)}} \\)   \\( = \\frac {\\partial E_{(1)}}{\\partial a_{(1)}^{(3)}} * sigmoid(z_{(1)}^{(3)}) * (1-sigmoid(z_{(1)}^{(3)})) * \\frac {\\partial z_{(1)}^{(3)}}{\\partial w_{(1,1)}^{(3)}} \\)   \\( = \\frac {\\partial E_{(1)}}{\\partial a_{(1)}^{(3)}} * a_{(1)}^{(3)} * (1-a_{(1)}^{(3)}) * \\frac {\\partial z_{(1)}^{(3)}}{\\partial w_{(1,1)}^{(3)}} \\)       preparation of backpropagation ...   입력층 선형회귀값 (z) * 없음 입력층 출력값 (a)\n   \\( a_{1}^{(1)} = x_{1} \\)       \\( a_{2}^{(1)} = x_{2} \\)    은닉층 선형회귀값 (z)\n   \\( z_{1}^{(2)} = a_{1}^{(1)} w_{1,1}^{(2)} \u0026#43; a_{2}^{(1)} w_{1,2}^{(2)} \u0026#43; b_{1}^{(2)} \\)       \\( z_{2}^{(2)} = a_{1}^{(1)} w_{2,1}^{(2)} \u0026#43; a_{2}^{(1)} w_{2,2}^{(2)} \u0026#43; b_{2}^{(2)} \\)    은닉층 출력값 (a)\n   \\( a_{1}^{(2)} = sigmoidz(z_{1}{(2)} \\)       \\( a_{2}^{(2)} = sigmoidz(z_{2}{(2)} \\)    출력층 선형회귀값 (z)\n   \\( z_{1}^{(3)} = a_{1}^{(2)} w_{1,1}^{(3)} \u0026#43; a_{2}^{(2)} w_{1,2}^{(3)} \u0026#43; b_{1}^{(3)} \\)       \\( z_{2}^{(3)} = a_{1}^{(2)} w_{2,1}^{(3)} \u0026#43; a_{2}^{(2)} w_{2,2}^{(3)} \u0026#43; b_{2}^{(3)} \\)    출력층 출력값 (a)\n   \\( a_{1}^{(3)} = sigmoidz(z_{1}{(3)} \\)       \\( a_{2}^{(3)} = sigmoidz(z_{2}{(3)} \\)       \\( E = \\frac {1}{n} \\displaystyle\\sum_{i=1}^{n}(t_{i}^{(3)} - a_{i}^{(3)})^2 = \\frac {1}{2} ( (t_{1}^{(3)} - a_{1}^{(3)})^2 \u0026#43; (t_{2}^{(3)} - a_{2}^{(3)})^2 ) \\)       \\( E_1 \u0026#43; E_2 = \\frac {1}{2} (t_{1}^{(3)}-a_{1}^{(3)})^2 \u0026#43; \\frac {1}{2} (t_{2}^{(3)}-a_{2}^{(3)})^2 \\)       \\( W^{(2)} = \\begin{pmatrix} w_{(1,1)}^{(2)} \u0026amp; w_{(2,1)}^{(2)} \\\\ w_{(1,2)}^{(2)} \u0026amp; w_{(2,2)}^{(2)} \\end{pmatrix} , W^{(3)} = \\begin{pmatrix} w_{(1,1)}^{(3)} \u0026amp; w_{(2,1)}^{(3)} \\\\ w_{(1,2)}^{(3)} \u0026amp; w_{(2,2)}^{(3)} \\end{pmatrix} \\)       \\( W^{(2)} = W^{(2)} - \\alpha \\frac {\\partial E}{\\partial W^{(2)}} \\to \\frac {\\partial E}{\\partial W^{(2)}} = \\frac {\\partial E}{\\partial W_{(1,1)}^{(2)}} , \\frac {\\partial E}{\\partial W_{(2,1)}^{(2)}} , \\frac {\\partial E}{\\partial W_{(1,2)}^{(2)}} , \\frac {\\partial E}{\\partial W_{(2,2)}^{(2)}} \\)       \\( W^{(3)} = W^{(3)} - \\alpha \\frac {\\partial E}{\\partial W^{(3)}} \\to \\frac {\\partial E}{\\partial W^{(3)}} = \\frac {\\partial E}{\\partial W_{(1,1)}^{(3)}} , \\frac {\\partial E}{\\partial W_{(2,1)}^{(2)}} , \\frac {\\partial E}{\\partial W_{(1,2)}^{(3)}} , \\frac {\\partial E}{\\partial W_{(2,2)}^{(3)}} \\)       \\( b^{(2)} = \\begin{pmatrix} b_{(1)}^{(2)} \u0026amp; b_{(2)}^{(2)} \\end{pmatrix} , b^{(3)} = \\begin{pmatrix} b_{(1)}^{(3)} \u0026amp; b_{(2)}^{(3)} \\end{pmatrix} \\)       \\( b^{(2)} = b^{(2)} - \\alpha \\frac {\\partial E}{\\partial b^{(2)}} \\to \\frac {\\partial E}{\\partial b^{(2)}} = \\frac {\\partial E}{\\partial b_{(1)}^{(2)}} , \\frac {\\partial E}{\\partial b_{(2)}^{(2)}} \\)       \\( b^{(3)} = b^{(3)} - \\alpha \\frac {\\partial E}{\\partial b^{(3)}} \\to \\frac {\\partial E}{\\partial b^{(3)}} = \\frac {\\partial E}{\\partial b_{(1)}^{(3)}} , \\frac {\\partial E}{\\partial b_{(2)}^{(3)}} \\)         formula induction ...    \\( \\frac {\\partial E} {\\partial W_{(1,1)}^{(3)}} = \\frac {\\partial E_{(1)}} {\\partial W_{(1,1)}^{(3)}} \u0026#43; \\frac {\\partial E_{(2)}} {\\partial W_{(1,1)}^{(3)}} = \\frac {\\partial E_{(1)}} {\\partial a_{(1)}^{(3)}} * \\frac {\\partial a_{(1)}^{(3)}}{\\partial z_{(1)}^{(3)}} * \\frac {\\partial z_{(1)}^{(3)}}{\\partial w_{(1,1)}^{(3)}} \\)   \\( = \\frac {\\partial \\begin{Bmatrix} \\frac{1}{2} (t_{(1)}^{(3)} - a_{(1)}^{(3)})^2 ) \\end{Bmatrix} } {\\partial a_{(1)}^{(3)}} * \\frac { \\partial sigmoid (z_{(1)}^{(3)}) } { \\partial z_{(1)}^{(3)} } * \\frac { \\partial ( a_{(1)}^{(2)} w_{(1,1)}^{(3)} \u0026#43; a_{(2)}^{(2)} w_{(1,2)}^{(3)} \u0026#43; b_{(1)}^{(3)} ) } { \\partial w_{(1,1)}^{(3)} } \\)  1)  \\( \\frac {\\partial \\begin{Bmatrix} \\frac{1}{2} (t_{(1)}^{(3)} - a_{(1)}^{(3)})^2 ) \\end{Bmatrix} } {\\partial a_{(1)}^{(3)}} = \\frac{1}{2} \\cdotp \\frac {\\partial (t_{(1)}^{(3)})^2 \u0026#43; (a_{(1)}^{(3)})^2 -2 t_{(1)}^{(3)} a_{(1)}^{(3)} } { \\partial a_{(1)}^{(3)} }\\)   \\( \\space \\space \\space \\space = \\frac{1}{2} \\cdotp (0 \u0026#43; 2*(a_{(1)}^{(3)})^{(2-1)} \u0026#43; -2 t_{(1)}^{(3)}) = a_{(1)}^{(3)} - t_{(1)}^{(3)}\\)  2)  \\( \\frac { \\partial sigmoid (z_{(1)}^{(3)}) } { \\partial z_{(1)}^{(3)} } = sigmoid(z_{(1)}^{(3)}) * (1-sigmoid(z_{(1)}^{(3)}))\\)  3)  \\( \\frac { \\partial ( a_{(1)}^{(2)} w_{(1,1)}^{(3)} \u0026#43; a_{(2)}^{(2)} w_{(1,2)}^{(3)} \u0026#43; b_{(1)}^{(3)} ) } { \\partial w_{(1,1)}^{(3)} } = a_{(1)}^{(2)} \u0026#43; 0 \u0026#43; 0\\)   \\( = (a_{(1)}^{(3)} - t_{(1)}^{(3)}) * sigmoid(z_{(1)}^{(3)}) * (1-sigmoid(z_{(1)}^{(3)})) * a_{(1)}^{(2)}\\)  여기서  \\( sigmoid(z_{(1)}^{(3)}) = a_{(1)}^{(3)}\\)   \\( = (a_{(1)}^{(3)} - t_{(1)}^{(3)}) * a_{(1)}^{(3)} * ( 1 - a_{(1)}^{(3)} ) * a_{(1)}^{(2)}\\)      Backpropagation2\n Vanishing Gradient\n   OpenTutorial \u0026#x21a9;\u0026#xfe0e;\n \u0026ldquo;Regression toward the mean\u0026rdquo;, Sir Francis Galton (1822~1911) \u0026#x21a9;\u0026#xfe0e;\n Global 해를 찾는 과정 \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':18,'href':'/docs/documents/deeplearning/tensorflow/','title':"Tensorflow",'section':"Deep Learning",'content':"Tensor Flow #   텐저 플로우는 2015년 구글에서 공개한 머신러닝 라이브러리. 케라스는 딥러닝 라이브러리를 Backend로 하는 신경망 모델 구성 라이브러리. 구글은 쥬피터 노트북이라는 오픈 소스 웹 어플리케이션을 코랩이라는 서비스를 통해 제공하고 있음.\nTensor Flow\nKeras\nPython\nJupyter Notebook\nColab\n이때 Tensor는 흘러다니는 데이터를 의미함.\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph LR A((X:Tensor))--|Edge|C((+:Node))--|Edge|D((X+Y:Tensor)) B((Y:Tensor))--|Edge|C style A fill:#ffffff,stroke:#000000,stroke-width:1px style B fill:#ffffff,stroke:#000000,stroke-width:1px style C fill:#ffffff,stroke:#000000,stroke-width:1px style D fill:#ffffff,stroke:#000000,stroke-width:1px 작성중\n"});index.add({'id':19,'href':'/docs/documents/business/','title':"Business",'section':"Documents",'content':"Business #     Supply Chain Management   Description   "});index.add({'id':20,'href':'/docs/documents/english/','title':"English",'section':"Documents",'content':"English #     Seulsam   English Expression from SeulSam   Picked Up English   Picked up english expressions here and there from web sites   "});index.add({'id':21,'href':'/docs/documents/english/seulsam/','title':"Seulsam",'section':"English",'content':"English Expression Diary - 구슬쌤 자신감 팍팍 영어 #   구슬쌤의 자신감 팍팍 영어를 정리\nI find it doable #  할만해.\nI find it challenging #  힘들긴하지만 해볼만해.\nDid you eat at all? #  뭐 좀 먹었니?\nIf you need anthing at all, please let me know. #  뭐라도 필요하시면 알려주세요.\nI\u0026rsquo;m in the middle of a meeting. Can I call you back in just a minute? #  한참 회의 중인데 좀있다 걸어도 될까?\nI\u0026rsquo;m at work. #  난 근무중이야.\nYou made my day. #  덕분에 기분 좋아.\nYou don\u0026rsquo;t appreciate good man. #  좋은 남자의 진가를 몰라보내.\nI appreciate it. Of course #  네 덕분이야. 천만에요. (?)\nThank you. No, thank YOU. #  고마워요. 천만에요.\nHow old do you think she is? I think.. she\u0026rsquo;s 30-ish. #  그 여자가 몇살인거 같니. 내 생각엔 대략 30살정도?\nThere\u0026rsquo;s always room for improvement. #  늘 개선의 여지가 있어요.\nI\u0026rsquo;m so flattered. #  과찬이세요.\nThank you for your compliment. #  칭찬 감사합니다.\nI hope you saved room for dessert. #  디저트 먹을 자리 남겨 놓았길 바래요.\nDo you have enough room? #  자리 공간 충분하세요?\nThere\u0026rsquo;s no room for mistakes. #  실수할 여유 없어\nThere\u0026rsquo;s no room for delay. #  지체할 여유 없어.\nI coundn\u0026rsquo;t have done it without you. #  잘 된건 다 네 덕분이야.\nI have so many things to do. I\u0026rsquo;m overwhelmed. #  해야 할게 너무 많아. 좀 벅차.\nIt\u0026rsquo;s overwhelming. #  감정이 벅차오른다.\nLet us not take this planet for granted. #  지구를 당연한 것으로 생각하지 말자.\nThis looks pretty legit. #  이거 꽤 괜찮아 보인다.\nAt least it was cheap. #  최소한 싸기라도 했다.\na variety of affordable options. #  다양한 합리적가격의 옵션들.\nShe is smart with her money. #  그녀는 합리적인 소비자다.\nYou\u0026rsquo;re acting/beging weird. #  너 오늘 행동이 이상해. (너 오늘 좀 이상해)\nStop being such a neat freak. #  좀 깔끔좀 고만 떨어.\nPlease stop being so bossy. #  상사질 좀 고만 해라.\nI\u0026rsquo;m freaking out. / Don\u0026rsquo;t freak out. #  엄청 당황했어. / 당황하지 마라.\nI almost freaked out. #  엄청 당황할뻔 했어.\nPlease bear with me. #  조금 참고 기다려주세요.\nIt\u0026rsquo;s that easy. #  그렇게나 쉬워요.\nIt\u0026rsquo;s not that easy. #  그렇게 쉽지 않아요.\nI owe you a drink. #  술한잔 살께요.\nI owe you an apology. #  내가 사과해야될거 같아요.\nI owe you an explanation. #  내가 설명드려야 될거 같아요.\nLet\u0026rsquo;s hit the road. #  빨리 가자.\nShe\u0026rsquo;s expecting. #  그녀는 출산 예정이다.\nI expect it done by the morning. #  내일 아침까지 끝낼지 두고 볼꺼야.\nI look forward to seeing you tomorrow. #  내일 널 볼걸 기대하고 있어.\nI am looking forward to seeing you tomorrow. #  내일 널 볼걸 지금 몹시 기대하고 있어.\nI\u0026rsquo;ve been looking forward to seeing you tomorrow. #  내일 널 볼걸 전부터 쭉 몹시 기대하고 있어.\nI can\u0026rsquo;t wait to see you. #  널 보는게 무척 기다려 진다.\nI can\u0026rsquo;t wait for tonight. #  오늘이 무척 기다려 진다.\nI know. #  그러게.\nYou know. #  있잖아.\nI mean #  내 말은, 다시 말하면.\nI\u0026rsquo;m telling you #  진짜야.\nCan you pick me up at 9:45 sharp. #  9:45에 딱 맞춰 태워 줄 수 있음?\nPicked you up some coffee. #  커피 좀 사다 줄까?\nDid you pick up on that? #  너 눈치 챘니?\nHow did you not pick up on that? #  어떻게 그걸 눈치 못챈거야?\nWhen did you pick up on that? #  그거 언제 눈치 챘어?\nI picked up some Japanese. #  난 일본어를 어깨 너머로 배웠어.\nI did pick up some Japanes during my high-school days. #  고등학교 시절에 일본어를 어깨넘어로 배웠어.\nWell, it\u0026rsquo;s sort of a bad habit I picked up being a consultant. #  컨설턴트 시절에 배웠던 안좋은 습관이죠.\nOkay, let\u0026rsquo;s call it a day. #  오늘은 여기까지 하자.\nWrap it up. #  정리 하자.\nI need to run an errand. / I need to run som errands. #  볼일이 좀 있어.\nLast but not least, #  마지막으로, 하지만 앞서 말한것 처럼 중요한.\nLet me make it up to you. #  당신에게 보답할 기회를 줘요.\nCoffee is my treat. I wanna make it up to you. #  커피는 내가 살게. 화 풀어주고 싶어서 그래.\nA six-figure income #  억대 연봉\nGive me a ballpark figure. How much? #  어림치로라도 얘기해줘. 얼마지?\nDon\u0026rsquo;t worry about the money. I\u0026rsquo;ll figure something out. #  돈은 걱정하지마. 어떻게든 방법을 찾아볼게.\nI\u0026rsquo;m struck in traffc. #  차가 막혀 꼼짝 못해.\nI need to take a rain check. I\u0026rsquo;m stuck at work. #  다음으로 미뤄야 할 것 같아. 회사에 일이 많아서 꼼짝못해.\nI wanna say thanks for doing this. #  이걸 해줘서 고맙다고 말하고 싶어.\nLet\u0026rsquo;s grab lunch sometime. #  언제 점심이라도 같이 하자.\nLet me go grab my phone. #  핸드폰 좀 가져올께.\nDo you want some company. / (I\u0026rsquo;d) love some company. #  같이 가줄까? / 좋지.\nI enjoy your company. #  같이 있어서 즐거웠어.\nI don\u0026rsquo;t mean to be late, but I\u0026rsquo;m stuck in traffic. #  늦고 싶지 않은데 차가 막히고 있어.\nI didn\u0026rsquo;t mean to be late, but I was stuck in traffic. #  늦고 싶지 않았는데 차가 막혔어.\nI don\u0026rsquo;t mean to interrupt, but I have extremely important news. #  방해하고 싶지 않지만 정말 중요한 뉴스가 있어.\nThis can wait. Let\u0026rsquo;s go get a drink. #  이거 나중에 해도 돼. 가서 술이나 한잔 하자.\nCan it wait? #  그거 이따 해도 돼?\nHow did it go? They both went well. Too well. #  어떻게 되고 있어? 두개다 잘 돼. 너무 잘 돼.\nHow did it go? It went well. / It didn\u0026rsquo;t go well. #  어떻게 돼고 있어? 잘 진행 됐어. 잘 진행되지 않았어.\nDid you go through every single page? #  하나도 빠짐 없이 잘 체크해봤어?\nI\u0026rsquo;m sorry you had to go through that. #  그걸 겪게 되어서 유감이야.\nSorry you had to go through that. #  네가 그런 일을 겪어야 했다니 유감이야.\nShe\u0026rsquo;s going through a lot. #  그녀는 많은 일들을 겪고 있어.\nThe payment didn\u0026rsquo;t go through. #  결제가 넘어가지 않았습니다.\nI\u0026rsquo;ll go with a latte. #  라떼로 하겠습니다.\nGo on. #  계속해.\nWhere does this part go? #  이건 부품은 어디 들어가지?\nCould you look over this email? #  이 이메일 좀 봐줄 수 있어?\nWhy don’t you look over some of our materials? #  우리 자료 좀 봐주지 않겠어?\nListen, did you get a chance to look over that contract for me? #  혹시 내가 보낸 계약서 훑어 볼 시간 있었어?\nLet’s go over this quickly. #  이걸 빠르게 훑어 봅시다.\nWe went over that yesterday. #  우리 어제 그거 훑어 봤어.\nExecuse me, we just went over this. #  실례하지만, 우리 우리 이거 방금 다뤘었자나?\nOkay, let’s go over the instructions. #  좋아, 설명서를 차근차근 읽어 보자.\nSo, let’s go over the plan again. #  그래서 다시 계획을 좀 더 살펴 보자.\nAnd yes, I’m thorough. #  그래 나 꼼꼼해.\nWe went over that thoroughly. #  우리는 그걸 꼼꼼하게 살펴보겠다.\nAnd you don’t look a day over 25. #  그리고 당신은 25을 넘어 보이지 않아.\nIt was an honest mistake. #  의도치 않은 실수였어.\nThat\u0026rsquo;s a pretty solid idea. #  꽤 괜찮은 생각인걸.\nThanks for the heads-up. #  미리 경고 해줘서 고마워.\nI’m at working right now. #  지금 근무중이야.\nThis is a heads-up. You got visitors. #  이건 경고야. 방문객이 있을거야.\nHappy Hump day. #  수요일 고비를 잘 넘겨보자.\nGuess what day it is. It’s hump day. #  오늘 무슨 날인지 맞춰 봐. 오늘 수요일이야.\nRSVP (please respond) #  참석여부 회신을 부탁드립니다.\nBut unfortunately. I don’t think I can make it. #  저 가려고 했는데 못 갈거 같아요.\nI can’t make it. #  못 가요\nI can’t go. #  저 못가요.\nNo RSVP required. Just be there. #  참석여부 없이 그냥 참석하세요.\nI got you something. #  널 위해 뭐좀 가져왔어.\nI got you some coffee. #  커피 좀 사왔어.\nI got lattes for the entire office. #  사무실 전체를 위해 랔데 좀 사왔어요.\nYou should get some sleep. #  잠 좀 자는게 좋겠다.\nYou should get some rest. #  좀 쉬는게 좋겠다.\nMy coffee is getting cold. #  내 커피가 점점 식어가네.\nMy coffee got cold. #  내 커피가 식었어.\nYour food getting cold. What are you doing? #  음식이 식잖아. 뭐 하는 거야?\nI hope you get better soon. #  나아지길 바랄게.\nGet well soon #  곧 나아지길 바랄께.\nCall me when you get to work. #  회사에 도착하면 전화해줘\nDid you get home safely? #  집에 잘 도착했어?\nGet home safely. #  조심히 들어가.\nGet home safe. #  조심히 들어가.\nI got it. #  이해했다.\nI\u0026rsquo;ll get her to send you the info. #  그녀한테 네게 문자로 정보 보내주라고 할게.\nI got him to quit smoking. #  그가 금연하게끔 설득하겠어.\nI\u0026rsquo;ll get her to call you right away. #  그녀 보고 지금 당장 전화드리라고 할께요.\nAnd get her to call me on this. #  그리고 그녀가 이걸로 전화하게끔 설득해.\nDid you get my email? #  내 이메일 받았어?\nDid you get my text? / I got your text. #  내 문자 받았어? 받았어.\nI just got a call from corporate. #  방금 본사로부터 전화 받았어.\nI didn\u0026rsquo;t see this coming. #  이렇게 될줄 몰랐어.\nSo what was your takeaway? #  오늘 니가 배운점은 뭐니?\nShall we gat a takeaway? #  포장 음식 어때?\nCan you come up with a plan by tomorrow? #  내일까지 계회 좀 준비 해줄래?\nI came up with a strategy. #  내가 전략을 마련했어.\nHow did you come up with the rent? #  월세를 어떻게 마련했니?\nMaybe come up with a better plan? #  좀더 나은 계획을 준비해줄 수 있어?\nI\u0026rsquo;m putting together a team. #  나는 팀원을 모으는 중이다.\nCan you put together a presentation? #  프레젠테이션 준비해줄 수 있어?\nCould you put together a presentation for tomorrow? #  내일 프레젠테이션 좀 준비해 줄 수 있어?\nSo I\u0026rsquo;ve put together a marketing campaign. #  그래서 내가 마케팅 캠페인을 준비했어.\nIt was worth it. #  가치가 있었다.\nDoes tomorrow work for you? #  내일 시간 돼?\nDo you work tomorrow? #  너 내일 근무 해?\nDoes Friday work for you? #  금요일에 시간 돼?\nDo you work on Friday? #  너 금요일에 근무해?\nI don\u0026rsquo;t think the wi-fi is working. #  와이파이가 안되는 것 같아요.\nI don\u0026rsquo;t think my lap-top is working. #  랩탑이 작동하지 않는거 같아요.\nI\u0026rsquo;ll keep you posted #  어떻게 진행되는지 알려줄께\nKeep me posted #  어떻게 진행 되는지 알려줘\nCan you move up the meeting? #  미팅 일정좀 당겨줄 수 있어?\nLet\u0026rsquo;s move on to the next topic. #  다음 주제로 넘어갑시다.\nLet\u0026rsquo;s move on to the next presentation. #  다음 프레젠테이션으로 넘어갑시다.\nCan we move on to the next question? #  다음 질문으로 넘어 갈까요?\nI need to move on. #  난 새출발이 필요해.\nLet\u0026rsquo;s pick this up tomorrow. #  내일 계속하자.\nLet\u0026rsquo;s pick this up after lunch. #  점심 먹고 계속하자.\nLet\u0026rsquo;s call it a day and pick this up tomorrow. #  오늘은 이쯤 하고 내일 다시 하자.\nI\u0026rsquo;ll go pick up some coffee. #  커피 좀 사올께.\nPicked you up some coffe. #  커피 좀 사왔어.\nAlso, I got you this coffee. #  또한, 여기 커피 좀 얻어 왔어.\nPlease let me know at your earliest convenience. #  편하실 때 말씀 부탁드립니다.\nPlease let me know A.S.A.P #  최대한 빨리 말씀 부탁드립니다.\nPlease let me know by Friday at the latest. #  늦어도 금요일까지 말씀 부탁드립니다.\nSign off on #  승인하다\nWrap up #  마무리하다\nBring up #  언급하다\nWork on #  공들이다.\nForward #  전달하다\nShe is turning 50 this year. #  그녀는 올해 50살이 돼.\nI\u0026rsquo;m turning 35 this year. #  나는 올해 35이 돼.\nI turned 35 this year. #  나는 올해 서른 35이 됐어.\nMy oldest just turned 30. #  큰애가 막 30이 됐어.\nNo, it\u0026rsquo;s my turn. #  아닙니다. 제 차례입니다.\nThings will turn around. #  상황이 나아질거야.\nThings will work out. #  다 잘 풀릴 거야.\nHow did it go? It went well. #  어떻게 됐어? 잘 됐어.\nSo how did the big meeting turn out? #  그 미팅 결과는 어땠어?\nTurns out it was for me. #  그거 내 취향이더라\nTurns out it was perfect for me. #  그거 완전 내 취향이더라.\nTurns out it wasn\u0026rsquo;t for me. #  그건 내 취향이 아니더라.\nIt might turn into a great opportunity. #  좋은 기회가 될지도 몰라.\nIt turned into a nightmare. #  최악의 상황이 됐어.\nI\u0026rsquo;ll turn it into something new. #  뭔가 새로운걸로 바꿔야 겠다.\nThis is turning into a nightmare. #  이건 지금 악몽이 되고 있는 중이야.\nCan you help me turn on the air? #  에어컨 좀 켜는것좀 도와줄래?\nI can turn off the air. #  에어컨 꺼줄 수 있어.\nIt\u0026rsquo;s cold. Turn up the heat. #  추워. 히터 좀 켜.\nI\u0026rsquo;d like to say thank you, but I\u0026rsquo;m gonna have to turn your offer down. #  고맙다고 말씀드리고 싶지만 제안은 거절 드려야할 것 같습니다.\nI\u0026rsquo;m gonna have to take a rain check. #  연기를 해야할 것 같아요.\nI\u0026rsquo;m gonna have to say no. #  안 된다고 말씀 드려야 할 것 같아요.\nDon\u0026rsquo;t forget to take your medicine. #  약 먹는거 잊지 마라.\nTake your vitamin. It\u0026rsquo;s the last one. #  비타민 먹어라. 마지막이야.\nI\u0026rsquo;ll take a cab. #  택시 탈거야.\nExecuse me, Could you take a picture of us? #  실례지만, 우리 사진 좀 찍어 줄래?\nTake a coffee break. #  커피 타임 갖자.\nWe should take a coffee break. Let\u0026rsquo;s all get coffee, okay? #  우리 커피마시면서 쉬자. 모두 커피 가져오는거야. OK?\nAll you guys, take a lunch break. #  너희들 모두 점심 휴식이야.\nLet\u0026rsquo;s pick this up after lunch. #  점심 먹고 계속하자.\nGood things take time. #  좋은 건 시간이 걸리기 마련이다.\nHow long would it take? #  얼마나 오래 걸릴까요?\nI\u0026rsquo;ll take it from here. #  여기서부턴 제가 맡을께요.\nWhy don\u0026rsquo;t I take you out to lunch? My treat. #  내가 점심살까? 내가 살께.\nI\u0026rsquo;d like to take you out for coffee sometime. #  언제 시간될때 커피한잔 사고 싶어요.\nCould I take you out for coffee sometime? #  언제 제가 커피한잔 살 수 있을까요?\nI\u0026rsquo;ll get the takeout menus. #  포장음식 메뉴 가져올께.\nI take full responsibility. #  내가 전적으로 책임을 지겠어.\nI can\u0026rsquo;t help but feel partially responsible. #  책임이 일부분 있다는 느낌을 지울 수 없네.\nTake responsibility for your actions. #  행동에 책임을 져야한다.\nTake responsibility for your mistakes. #  너의 실수에 책임을 져야한다.\nI just wanna take advantage of this opportunity. #  그냥 이 기회를 잘 활용해보고 싶어.\nDon\u0026rsquo;t take advantage of me. #  나를 악용하지 마.\nWe don\u0026rsquo;t wann take advantage of your hospitality. #  당신의 호의를 너무 이용하고 싶지 않습니다.\nCan you take off your shoes, please? #  신발 좀 벗어 주시겠어요?\nDo you want me to take off my shoes? #  제가 신발을 벗길 원하시나요?\nSorry guys, but I gotta take off. #  나 지금 가봐야 돼.\nI gotta go. #  가봐야돼.\nI gotta run. #  가봐야돼.\nI am just frustrated. #  나 답답해.\nThis is so frustrating. #  이거 정말 짜증나는걸.\nI am so embarrassed. #  이거 정말 민망해\nThis is so embarrassing. #  이거 민망한걸.\nHe is embarrassed #  그는 민망해했다.\nHe is embarrassing. #  그는 민망한 사람임.\nDevastated, simply devastated. #  충격받았어. 단순히 충격받았어.\nDad was devastated. #  아빠는 충격받았다.\nI am upset #  나 속상해\nThat\u0026rsquo;s upsetting #  그거 속상하네.\nI\u0026rsquo;m humiliated. #  굴욕적이야.\nGod. this is so humiliating. #  오 신이여. 이건 정말 치욕적이야.\nWhat kind of work to do. #  어떤 종류의 일을 하니?\nWhat kind of music do you like? #  어떤 종류의 음악을 좋아하니?\nI’m kind of hungry. #  나 쫌 배고파\nI’m kinda hungry. #  나 쫌 배고프네.\nI’m kinda tired. #  난 좀 파곤해\nI kinda like her. #  난 좀 그녀가 맘에 들어.\nIt’s kinda getting warm. #  날씨가 좀 따뜻 해지네.\nIt’s kind of getting hot. #  쫌 점점 더워지는데.\nI’m sorta busy right now. #  지금 쫌 바빠.\nSorta like this weather. #  지금 이 날씨가 쫌 좋아.\nSorry about the mess. #  정돈이 안되서 미안.\nSorry, it’s a bit messy. #  미안 좀 어수선하네.\nIt’s a little messy. #  좀 어수선하네요.\nAlso, do not forget that he has just gone through a messy divorce. #  또한 그는 막 골치아픈 이혼을 겪었다는걸 잊지 마세요.\nDon’t mess with me. #  장난치지마.\nYoue’re messing with the wrong person. #  너 지금 사람 잘 못 건드렸어.\nI messed up everything. #  내가 다 망쳤어.\nDon’t mess it up. #  망치지지마.\nI don’t wanna mess it up, you know? #  난 망치고 싶지않아. 알아?\nI’m sorry I messed up your flowers and everything. #  네 꽃과 모든걸 망쳐서 미안해.\nI saw this coming #  이렇게 될 줄 알았어.\nI saw that coming. #  그렇게 될 줄 알았어.\nI didn’t see this coming. #  난 이럴 줄 몰랐어.\nYou saw this coming? / Yeah, everyone saw this coming. #  이렇게 될줄 알았니? / 모두가 알았어.\nDidn’t see that comig. #  그렇게 돨줄 몰랐는데.\nSorry. Something’s come up, and I gotta run. #  미안 무슨일이 생겨서 빨리 가봐야돼\nI need to run an errand. #  나 볼일이 있어.\nI need to run some errands. #  나 볼일이 좀 있어.\nI’ve been running around all day. #  하루종일 여기저기 다니느라 정신이 하나도 없어.\nHe runs a convenience store. #  그는 편의점을 운영하고 있어.\nWho runs this place? #  누가 여기 책임자지?\nI need to speak to the person in charge? #  담당자와 얘기 하고 싶다.\nMay I speak to the person in charge? #  담당자와 이야기 할 수 있나요?\nSorry I’m late. Class ran long. #  늦어서 미안해. 수업이 늦게 끝났어.\nI ran into her the other day. #  저번에 지나가다 우연히 그녀를 만났어.\nGlad I ran into you. #  이렇게 우연히 보니 반가운걸.\nWe ran into some problems. #  문제 들에 부딪혔어.\nI ran into some trouble. #  곤란에 부딪혔어.\nI ran across an interesting article the other day. #  저번에 흥미로운 기사를 우연히 발견했어.\nI ran across an interesting quote the other day. #  저번에 흥미로운 문구를 우연히 발견했어.\nThese days, it’s hard to run across someone without mask. #  요즘은 마스크를 쓰지 않은 사람을 접하기가 어려워.\nYou are not exactly the smartest guy I ever ran across. #  내가 접해본 사람 중 가장 똑똑한 사람은 아니야.\nAnd I’ve never run across anyone quite like you. #  지금까지 너같은 사람은 만나 본 적이 없어.\nLet’s run this by him first. #  먼저 그에게 조언을 받읍시다.\nWell, I’ll call him and run it by him. #  그에게 전화해서 조언을 받을께.\nDon’t worry. I’ll run it by you before I press any buttons. #  걱정하지마, 뭘 결정하기정에 당신과 상담하겠어.\nWe’re running out of time. #  시간이 얼마 안남았어.\nWe’re running out of money. #  돈이 다 떨어져가.\nWe’re running our of gas. #  기름이 다 떨어져가.\nI’m running out of patience. #  인내심이 바닥 나고 있어.\nLet’s quickly run through this list. #  이 리스트를 재빨리 훑어 보자.\nLet’s do a quick run-through. #  우리 재빨리 연습해보자.\nYou’re so generous. #  너 너무 고맙다.\nThis is so generous. #  이거 너무 고마운걸.\nThis is too generous. #  너무 고맙다.\nThis is too much. #  너무 과하다.\nI can’t accept this. It’s too much. #  이걸 받을 수 없어. 너무 과해.\nI insist. #  거절 말어.\nOn us / Oh, no thank you. I insist. #  저희가 살께요. / 아니에요. 괜찮습니다. 거절마세요.\nThat’s too generous. / No, I insist. #  너무 과하다. / 아니 거절하지마.\nIt’s the least I can do. #  그 정도는 내 최소한의 도리.\nI have a simple question. #  이건 간단한 질문이야.\nWell, it\u0026rsquo;s a simple question. Do you love the guy or not? #  이거 간단한 질문이잖아. 그를 사랑해 아니야?\nI have a quick question. #  나는 간단한 질문이 있어.\nCan I ask you a quick question? #  간단한거 물어봐도 될까?\nI\u0026rsquo;d like to ask you a quick question. #  간단한 질문을 묻고 싶어.\nJust a quick question. #  간단한거 하나만.\nWhat are you doing? #  뭐하는거냐?\nWhat are you working on? #  뭐 그리 열심히 하니?\nI\u0026rsquo;m working on it. #  지금 열심히 하고 있어.\nAre you okay? #  확실히 문제있는 상황에서 너 괜찮아?\nIs everything okay? #  아무일 없지? 괜찮니?\nI made you some coffee. #  내가 너를 위해서 커피를 만들었어.\nI picked you up some coffee. #  내가 너를 위해 커피를 사왔어.\nI got you some coffee. #  내가 너를 위해 커피를 얻어왔어.\nI went to the Asian market, got the ingredients, and made it from scratch. #  아시아 시장에 가서 재료를 사다가 처음부터 끝까지 다 만들었어.\nIt\u0026rsquo;s all good, I\u0026rsquo;ll make it work. #  괜찮아, 되게 할께.\nMake it work. #  되게 해.\nYou made it. / We made it. #  너 해냈구나. 너 왔구나. / 우리가 했냈다.\nI hope you can make it. #  올 수 있으면 좋겠어.\nI can\u0026rsquo;t go. #  난 못간다.\nI can\u0026rsquo;t make it #  가려고 했는데 못가요.\nI don\u0026rsquo;t think I can make it. #  가려고 했는데 못 갈 것 같아요.\nI really don\u0026rsquo;t feel very comfortable making this decision. #  나는 정말 이 결정을 내리는게 불편하네.\nI don\u0026rsquo;t feel comfortable going there. #  거기 가는게 불편해.\nI don\u0026rsquo;t feel comfortable asking her. #  그녀에게 묻는게 편치 않아.\nI\u0026rsquo;m not comfortable with this. #  이건 정말 마음이 편치않아.\nThat\u0026rsquo;s not your decision to make. #  그건 니가 내릴 결정이 아냐.\nI\u0026rsquo;ll make a note of it. #  메모해둘게. 기억할게.\nPlease, make a note of this. #  이거 꼭 기억해두세요.\nWe\u0026rsquo;re making every effort department wide to fix this problem. #  이 문제를 해결하기 위해 전 부서에 걸쳐 정말 애쓰고 있습니다.\nWe\u0026rsquo;re making every effort department wide to continue to find ways to assist you in this challenge. #  이 어려운 상황에서 당신을 돕울 방법을 찾기 위해 전 부서가 모든 노력을 아끼지 않고 있다.\nWe\u0026rsquo;re doing everything we can. #  우리가 할 수 있는거 다하고 있어.\nI\u0026rsquo;ll make it up to you. #  나중에 보답할께.\nHow can I make it up to you? I\u0026rsquo;ll take you to dinner tonight. #  어떻게 해야 화가 풀리겠어? 저녁식사를 대접하고 싶어.\nMake the most of your day. #  당신의 하루를 잘 이용해라.\nHave a good day. #  좋은 하루 되라.\nEnjoy the rest of your day #  남은 하루 즐겁게 보내라.\nSo make the most of this opportunity. #  그래서 이 기회를 잘 활용해봐.\nI hope we\u0026rsquo;ll meet again. / I\u0026rsquo;ll make sure we do. #  당신을 또 봤으면 좋겠어. 분명히 그렇게 되도록 할꺼야.\nI\u0026rsquo;ll make sure this doesn\u0026rsquo;t happen again. #  다시는 이런일이 생기지 않도록 하겠다.\nI\u0026rsquo;m supposed to meet friends downtown. #  친구들이랑 다운타운에서 만나기로 했어.\nI\u0026rsquo;m going to meet friends downtown. #  친구들이랑 다운타운에서 만날거야.\nIt\u0026rsquo;s supposed to rain today. #  오늘 비온다고 하더라.\nIt\u0026rsquo;s supposed to rain tomorrow, right? #  내일 비온다고 했지, 맞아?\nIt\u0026rsquo;s supposed to snow today. #  오늘 눈 온다고 하더라.\nIt\u0026rsquo;s supposed to be hot today. #  오늘 덥다고 하더라.\nIt\u0026rsquo;s supposed to be cold early next week. #  다음주 초는 춥다고 하더라.\nCome on, You\u0026rsquo;re not supposed to do that. #  오우, 너 원래 그러면 안되는 거잖아.\nNot supposed to smoke in here. #  여기서 담배피시면 안돼요.\nI don\u0026rsquo;t think you\u0026rsquo;re supposed to do that. #  원래 그러면 안되는 것 같은데.\nI was supposed to hang out with my friends, but I was too tired. #  어제 친구랑 만나기로 했는데 피곤해서 안만났어.\nI was supposed to study English, but I was too busy. #  영어 공부하기로 했었는데 너무 바빴어.\nSee, this was supposed to be easy and fun. #  봤지, 이건 원래 쉽고 재밌어야 했어.\nWe were supposed to meet for lunch, but he didn\u0026rsquo;t show. #  원래 우린 점심 먹기로 되어 있었는데 그가 안나타났어.\nWhere am I supposed to go? #  어디로 가라는 거냐?\nWhat am I supposed to do? #  나보고 어쩌라는 거냐?\nWhat\u0026rsquo;s that supposed to mean? #  무슨 의미 인거냐?\nIt\u0026rsquo;s supposed to be hard. If it wasn\u0026rsquo;t hard. Everyone would do it. The hard is what makes it great. #  원래 어려워야 하는데 어렵지 않다면 모두들 그럴거야. 어려움 자체가 위대하게 만드는 거야.\nIt\u0026rsquo;s supposed to be hard. #  원래 어려운거야.\nThere are a lot of job seeker tools. #  저기에는 많는 구직 도구들이 있습니다.\nI\u0026rsquo;m looking for a job. #  저는 구직중입니다.\nI\u0026rsquo;m in between jobs. #  저는 구직중입니다.\nWhat do you do for a living? I\u0026rsquo;m in between jobs. #  무슨일을 하니? 구직중이야.\nI\u0026rsquo;m in between jobs at the moment. #  지금 구직중이야.\nHere\u0026rsquo;s my card. #  내 명함이야.\nCan I have your card? Sure, here\u0026rsquo;s my card. #  명함좀 줄래? 여기 내명함.\nHere\u0026rsquo;s my card. If you \u0026rsquo;re ever free, give me a call. #  여기 내 명함. 편해지면 전화줘.\nIt\u0026rsquo;s on the house. / It\u0026rsquo;s on us. #  이거 공짜입니다.\nOn us. / Oh, no, thank you. #  공짜입니다. 오 아니요 감사합니다.\nCoffee is on me. #  커피는 내가 쏠께.\nThanks for all the hard work this week, guys! And as a thank you, lunch is on me. My treat. #  이번주 열심히 해줘서 고마워. 감사의 표시로 점심 살께. 내가 대접하는거야.\nTime flies. I miss college. #  시간 빨리 간다. 대학시절이 그립네.\nHow did you first meet? We meet in college. #  어떻게 처음 만났어? 우리 대학에서 만났어.\nWere do you go to school? #  학교 어디 다니니?\nWhere did you go to school? #  학교 어디 나왔니?\nHey! Where are you? Are you still at work? #  헤이! 어디니? 아직도 근무야?\nI like dog. #  나 개고기 좋아해.\nI like dogs. #  난 개를 좋아해.\nI\u0026rsquo;m a dog person. #  난 강아지를 좋아하는 사람이야.\nI\u0026rsquo;m a cat person. #  난 고양이를 좋아해.\nI\u0026rsquo;m a people person. #  나는 사교적인 사람이야.\nI\u0026rsquo;m a morning person. #  난 아침형 인간이야.\nI\u0026rsquo;m a coffee person. #  난 커피를 좋아해.\nAre you a dog or a cat person? #  넌 강아지랑 고양이중 뭐가 좋니?\nAre you a dog person? No, Actually, I\u0026rsquo;m more of a cat person. #  개 좋아하니? 아니, 사실 고양이를 더 좋아해.\nI\u0026rsquo;m more of a night person. #  나는 저녁형 인간에 더 가까워.\nDo you like cats? I\u0026rsquo;m more of a dog person myself. #  고양이 좋아하니? 나는 좀더 개를 좋아해.\nI\u0026rsquo;m not much of a dog person. #  난 개를 좋아하는 사람이 아니야.\nI\u0026rsquo;m not much of a drinker. #  전 술 별로 안 좋아해요.\nI took a semester off. #  나 한한기 휴학했어.\nI\u0026rsquo;m taking a semester off from school. #  나 지금 한학기 쉬고 있는 중이야.\nI\u0026rsquo;m actually not feeling so hot. Yeah, you should take the day off and feel better. okay? #  나 지금 뭔가 열정적이지 않아. 그래 그럼 하루 쉬고 좀 나아져. OK?\nI\u0026rsquo;m not feeling well. #  나 컨디션이 별로야.\nTake the rest of the day off. #  남은 하루는 집에 가서 쉬어.\nGet some rest. #  좀 쉬어라.\nTake the rest of the afternoon off. Take a sick day. #  오후는 퇴근하고 들어가서 쉬어. 하루는 쉬어라.\nTake this Friday off. #  이번주 금요일은 쉬어라.\nTake a year off. #  일년을 쉬어라.\nShe\u0026rsquo;s on marternity leave right now. #  그녀는 지금 출산 휴가 중이야.\nSpeak English. (jargon) #  알아 듣게 얘기해봐.\nFinally, someone who speaks English. It\u0026rsquo;s good to meet you, Dr. Banner. #  이제야 말이 통하는 사람을 만났네. 만나서 반갑다. 닥터 배너.\nI lied. I said that that was the last item. I actually have one more artifact still to come. #  실수했네요. 저게 마지막 아이템이라고 얘기했는데 사실 하나더 있습니다.\nI lied, I do have a favorite line. It\u0026rsquo;s when Burr says at the end of the show. #  실수 했네. 정말 좋아하는 문장이 있어. 버르가 쇼 마지막에 하는거야.\nOh. Sorry. My bad. #  오 미안, 내가 실수 했어.\nThis has got the three categories on the bottom, oh actually four, I lied, four categories. #  바닥에 세개 카테고리입니다. 오 네개네요. 제가 실수했네요. 네개 카테고리입니다.\nYou\u0026rsquo;re silly. / Yep, I am silly. #  너 참 엉뚱해. 그래 난 엉뚱해.\nDon\u0026rsquo;t be silly. #  장난 그만해.\nYou\u0026rsquo;re being silly. #  너 엉뚱하게 행동하네.\nYou\u0026rsquo;re silly. Well a little. #  너 엉뚱해. 글쎄 조금.\nYou\u0026rsquo;re all stupid. #  너희들 다 멍청해.\nStupid pen! #  짜증나는 펜.\nHe was up all night working on his stupid project. #  그는 그 짜증나는 프로젝트하나라고 밤을 샜어.\nAre you sure? / I am sure. #  정말 그래도 돼? 그래도 돼.\nDeep down. #  내심.\nAre you sure? That would be nice. You\u0026rsquo;re an angel. You\u0026rsquo;re the best. #  정말? 고마워. 넌 천사야. 니가 최고야.\nAre you sure? / I\u0026rsquo;m positive. Take the pen. #  정말요? 그래. 펜가져.\nOh, I\u0026rsquo;ll get it. Are you sure? #  가져올께. 정말?\nLet\u0026rsquo;s talk about this over lunch. #  점심 먹으면서 얘기하자.\nLet\u0026rsquo;s discuss this over lunch. #  점심 먹으면서 얘기하자.\nThat\u0026rsquo;s a good question. Let\u0026rsquo;s talk more over lunch. #  좋은 질무니야. 점심 먹으면서 얘기하자.\nI hope you got something out of it. #  유익 했길 바래요.\nWhy don\u0026rsquo;t we talk about this over lunch? #  점심 먹으면서 이거 얘기해보는게 어때?\nWhy don\u0026rsquo;t we talk about this over dinner? #  저녁 먹으면서 얘기해보는게 어때?\nLet\u0026rsquo;s talk about this over coffee. #  커피마시면서 얘기해보다.\nHe\u0026rsquo;s on the phone #  그는 통화 중이야.\nAre you on the phone? #  지금 통화 중이야?\nI\u0026rsquo;m on the phone. #  나 지금 통화중이야.\nWe spoke on the phone. #  우리 전화 통화 했었죠.\nCan you put Mike on the phone? #  Mike 좀 바꿔 줄래?\nCould you put Carrie on the phone, please? #  캐리좀 바꿔줄래?\nYou sounded upset on the phone. #  통화할때 속상해 하는 것 같더라.\nHey. Is everything okay? You sounded weird on the phone. #  전화 통화할때 평소와 다르던데 아무일 없지?\nCan I make a reservation over the phone? #  전화로 예약 가능 한가요?\nDo I have to do it in person or can I do it over the phone? #  직접 가서 해야 하나요? 아니면 전화로 해도 되나요?\nThanks again for letting me pay over the phone. #  전화로 지불할 수 있게 해줘서 고마워.\nIt\u0026rsquo;s too complicated to explain over the phone. #  전화로 하기에는 너무 복잡해.\nI\u0026rsquo;m not comfortable giving you that information over the phone. #  전화상으로 그런 정보를 드리는게 불편하네요.\nBecause he didn\u0026rsquo;t wanna relay that kind of information over the phone. #  왜냐하면 그는 전화로 그런 종류를 전해주고 싶지 않았을거야.\nNo, I\u0026rsquo;d rather not do it over the phone. #  아니요. 저는 전화상으로 그것을 하고 싶지 않습니다.\nWhat did you do over the weekend? #  주말에 뭐했니?\nLet\u0026rsquo;s talk about it over lunch. #  점심 먹으면서 얘기하자.\nCan I just do it over the phone? #  전화로 할수 있나요?\nWe can\u0026rsquo;t discuss them over the phone? #  전화상으로 이야기 할 수 없나요?\nI need to work late tonight. #  늦게 까지 야근 해야 해.\nYou are working late. #  야근하는 구나\nI had to work late. #  야근 해야돼.\nFingers crossed for overtime pay. #  야근수당 나오면 좋겠다.\nHow do you know each other? We work together. #  어떻게 아는 사이인가요? 우리 같이 일해요.\nWe used to work together. #  우리 예전에 같이 일했어요.\nWhat time do you get off work? #  몇 시에 퇴근하니?\nWhat time do you get off tonight? #  오늘 언제 퇴근하니?\nI get off work at six. #  나 여섯시에 퇴근해.\nYour hard work just paid off. #  열심히 일한 보람이 있네.\nI mean I’m a real hard worker. #  저는 정말 열심히 일하는 사람입니다.\nI mean, it’s not lick. You’re a very hard worker. #  그건 단지 운이 아니야. 당신은 근면 성실한 사람이야.\nKeep up the good work, everyone. #  다들 수고하게.\nThis is very impressive work. #  매우 대단하네.\nImpressive work. #  대단하네.\nI’m impressived. #  대단하네.\nI don\u0026rsquo;t think the wi-fi is working. #  와이 파이가 안되는 거 같아.\nI don’t think this working. #  이거 안되는거 같아.\nDoes Monday work for you? #  월요일 시간 돼?\nDo you work on monday? #  너 월요일에 근무해?\nDoes the first week of February work for you? #  2월 첫주 시간 돼?\nDoes tomorrow work fo you at all? #  내일 잠깐이라도 시간 돼?\nDoes today work for you at all? #  오늘 잠깐 시간 돼?\nYou look good. Have you been working out? #  너 괜찮아 보인다. 요즘 운동하니?\nI hope everything works out for you. #  네게 모든 일이 잘 풀렸으면 좋겠다.\nI hope everything works out well. #  모든게 잘 풀렸으면 좋겠다.\nI\u0026rsquo;m gonna make sure everything works out. #  모든게 잘돼도록 확실히 하께.\nWhat are you working on? #  뭘 그렇게 열심히 하고 있니?\nWe’ve been working on this side project. #  우리는 이 부수 과제를 열심히 했다.\nYou need to work on your people skills. #  너는 대인 관계 기술 좀 개선해야돼.\nYou really need to work on your listening skills. #  너는 정말 듣기 연습좀 해야겠다.\nI’m working on it. #  지금 그거 열심히 하고 있어요.\nMaybe you could start thinking about an exit strategy. / I’m working on it. #  아마 너는 출구 전략 고민을 시작 할 수도 있다. 그러려고 노력 중이다.\nDon’t worry. I’m working on it. #  걱정마. 지금 열심히 하는 중이야.\nWe’ll work around your schedule. #  우리가 내 스케쥴에 맞출께.\nI’m free. #  나 한가해.\nI’m available. #  나 가능해.\nAbsolutely, We’ll work around your schedule. #  당연하죠. 저희가 당신의 일정에 맞출께요.\nWe can work through this. #  우린 이걸 헤쳐나갈 수 있어.\nWhat we have is too important. We can work through this. #  우리가 가지고 있는건 너무 중요한거야. 우린 이걸 헤쳐나갈 수 있어.\nI work through lunch. #  점심 안먹고 일했어. (점심 떼우고 일했어)\nI’m gonna work through lunch. #  점심 안먹고 일할거야.\nI work Monday through Friday. #  월요일 부터 금요일 까지 근무한다.\nI hope you get better. #  곧 낫길 바랍니다.\nI wish today were Friday. #  오늘이 금요일이면 좋겠어.\nI wish it wete Friday. #  금요일이였으면 좋겠어.\nI wish every day was Sunday. #  모든날이 일요일이였으면 좋겠어.\nCould you help me (out) with something? #  나 좀 도와 줄 수 있니?\nI wish I could but I can’t. #  그러고 싶은데 못해.\nSo, help us out. Wish I could, but I can’t. #  그래서 우리좀 도와줘. 그러고 싶지만 못해.\nCould you help me out with something? #  뭐 좀 오와줄 수 있어?\nCould you help me out with the presentation? #  프레젠테이션 좀 도와 줄 수 있니?\nCould you help me out with my resume? #  내 이력서좀 도와줄래?\nCan you help me out with that? #  그것 좀 도와줄 수 잌ㅅ니?\nSure, I’m happy to help you out with this. #  물론 난 이걸로 널 도와주면 기쁘다.\nI wish you were here. #  네가 여기 있다면 좋을텐데.\nI miss you and I wish you were here. #  네가 그립고 여기 있었으면 좋겠어.\nI wish things were different. #  상황이 달랐으면 좋겠다.\nI wish things were different. I really do. #  상황이 달랐으면 좋았을텐데. 정말 그래.\nWe wish you a merry Christmas. #  We hope you have a merry Christmas.\nWish me luck. #  Please hope that I have good luck.\nI called to wish you luck at the conference. #  컨퍼런스 잘하라고 전화했다.\nGood luck with her not that you need it. #  그녀랑 잘돼길 바래. 너한텐 필요없겠지만.\nAnway, not that you need it, but good luck. #  어쨌건 필요없겠지만 행운을 빈다.\nNonetheless, I wish you all the best in your efforts. #  그럼에도 불구하고, 노력에 보답받기를 바란다.\nI wish you the best. #  좋은 일만 일어나길 바란다.\nI wish you the very best. #  좋은 일만 일어나길 바래.\nAnd I wish you the very best of luck. Thank you. #  여러분 모두에게 좋은 일만 일어나길 바라겠습니다. 감사합니다.\nThere are things I wish to say. #  말하고 싶은게 있어.\nI don’t wish to discuss it further. #  이건 더이상 얘기하고 싶지 않아.\nI simply don’t wish to discuss it further. #  난 단순히 더이상 그걸 얘기하고 싶지 않아.\nExactly, what happened? It’s complicated, And I don’t wish to discuss it. #  정확히 뭐가 일어났니. 좀 복잡한데 더 이상 얘기하고 싶지 않아.\nI wish to soeak to the manager. #  매니저와 얘기하고 싶다.\nTake me to the one in charge. I wish to speak to him. #  나를 책임자에게 데려다 주시오. 그와 얘기하고 싶소.\nI wish to see her. #  그녀를 뵙고 싶습니다.\nI hope to see her. #  그녀를 뵐수 있길 바래요.\nI hope you’re having a great day. #  좋은 날 보내시길 바래요.\nHi, hope you’re having a good day. #  안녕 좋은날 보내길 바래.\nI hope you enjoyed your lunch. #  점심식사 맛있게 하시길 바래요.\nHope you had a pleasant flight. #  즐거운 비행 되시길 바래요.\nWhen they are literally on their deathbeds. Number one. I wish I hadn’t worked so hard. #  정말 임종을 앞두었을때. 첫번째. 그렇게 열심히 일하지 말걸.\nYou must be Ms.Lee. Please call me Sunja. #  이양이시군요. 순자라 불러주세요.\nMrs\u0026hellip;(Should) at least be Ms.? #  미쎄스\u0026hellip; 최소한 미쓰네.\nPleasure to meet you Ms. Bennett. That’s Mrs. Bennet, sweetheart. #  만나서 반갑습니다. 미스 버넷양. 미쎄스 버넷이네. 이양반아.\nNow Mr. Fischer was my father’s name. Call me Bert, please. #  미스터 피셔는 아버지 이름입니다. 버트라고 불러주세요.\nYou look tired today? #  너 오늘 피곤하니?\nYou look tired. Did you not sleep? #  피곤해 보이네. 잠은 잤어?\nYou look tire. Why don\u0026rsquo;t you go home, get some rest. #  피곤해 보이는데 퇴근하고 집에가서 쉬는게 좀 어때?\nGot you a little pick-me-up. #  이거 먹고 힘내.\nLet me know if there\u0026rsquo;s anything I can do to help. #  내가 도와 줄 수 있는게 뭐라도 있으면 말해줘.\nI don\u0026rsquo;t care. #  관심 없어.\nI don\u0026rsquo;t care how long it takes, I will keep you here all night. #  얼마나 오래걸리는지 상관없어. 나는 너희들을 밤새도록 붙잡고 있을거야.\nI don\u0026rsquo;t care how long it takes. Just get it done. #  얼마나 오래 걸리는지 상관없어. 그냥 해.\nI don\u0026rsquo;t care about what you think. #  네가 뭘 생각하는 난 신경안써.\nYou know, we don\u0026rsquo;t really care about your opinion. #  우리가 네 의견을 신경안쓰는지 알잖아.\nI couldn\u0026rsquo;t care less. #  진짜 1도 관심 없어.\nDon\u0026rsquo;t care. Counldn\u0026rsquo;t care less. #  신경안써. 진짜 관심없어.\nI really couldn\u0026rsquo;t care less. #  진짜 1도 관심없어.\nAnything. It doesn\u0026rsquo;t matter to me. #  뭐든 상관없어.\nI\u0026rsquo;m good/fine with whatever. #  뭐든 좋아.\nIt doesn\u0026rsquo;t matter to me, your choice. #  상관없으니 니가 골라.\nLet\u0026rsquo;s eat. I\u0026rsquo;m good with whatever. #  먹자고. 나는 뭐든 상관없어.\nAnywhere. It doesn\u0026rsquo;t matter to me. #  어디든 상관없어.\nI\u0026rsquo;m good/fine with wherever. #  어디든 좋아.\nAre you with me? #  내 말 이해했어?\nAre you/we on the same page? #  잘 따라 오는 거지? 이해하는 거지?\nLet me make sure we\u0026rsquo;re on the same page. #  제가 잘 이해한건지 확인차 여쭤봅니다.\nWe\u0026rsquo;re 100% on the same page. #  100% 같은 생각입니다.\nWe\u0026rsquo;re not on the same page. #  같은 생각이 아니야.\nI don\u0026rsquo;t think we\u0026rsquo;re on the same page. #  같은 생각이 아닌거 같아.\nWe\u0026rsquo;re getting there. #  이해가 되어가고 있다.\nNot quite. But we\u0026rsquo;re getting there. #  아직은 아니지만 점점 합의점에 도달하고 있다.\nAre you on the same page with this matter? We\u0026rsquo;re not so far away. #  이 문제에 대해 생각이 같은가요? 그렇게 다르진 않다.\nYou\u0026rsquo;ll get there. #  목표에 도달할거다.\nThere\u0026rsquo;s still room for improvement. #  여전히 개선의 여지가 있다.\nI\u0026rsquo;ll get there. #  목표에 도달할거야.\nI feel confident that we\u0026rsquo;ll get there. #  나는 목표에 도달할 자신감은 느낀다.\nCould you bring me up to speed? #  지금 어떻게 진행되고 있는지 알려줄 수 있어?\nI can bring you up to speed. #  현상황을 내가 알려줄께.\nCan I bring you up to speed over dinner? #  저녁 먹으면서 어떻게 된지 얘기 해줘도 될까?\nThen why don\u0026rsquo;t you sit down, and I\u0026rsquo;ll bring you up to speed? #  그럼 앉는게 어때? 내가 어떤 상황인지 이야기할게.\nJust to bring everybody up to speed, I\u0026rsquo;ve put together a brief report. #  모두에게 현상황을 알려드리기 위해 간단한 보고서를 준비했습니다.\nSo just to bring everybody up to speed, let\u0026rsquo;s define what we\u0026rsquo;re actually talking about. #  모두가 이해할 수 있게 우리가 실제로 무언에 관해 논의 했는지를 정의해봅시다.\nWhere were we? #  우리가 어디까지 했지?\nWhere are we? #  우리가 어떤 상황이지?\nWhere are we on the deal? Waiting on documents from overseas. #  그 거래는 어떤상황이지? 해외 서류를 기다리고 있다.\nWhere are we ont eh process of it? #  현재 어디까지 진행된거죠?\nWhere are you going with this? #  무슨 말을 하려는거야?\nWhat\u0026rsquo;s your point? #  요점이 뭐니?\nWhere are you going with this? I want a divorce. This isn\u0026rsquo;t working anymore. #  무슨 말을 하려는거야? 이혼을 원해. 이건 통하지 않을거야.\n"});index.add({'id':22,'href':'/docs/documents/english/pickedup/','title':"Picked Up English",'section':"English",'content':"English Expression Diary #   A little bird told me #  동문서답으로 \u0026lsquo;그냥 주워들었어\u0026rsquo; 표현. \u0026lsquo;Tell me. Where did you hear that?\u0026rsquo; \u0026lsquo;A little bird told me.\u0026rsquo;\nBigger fish to fry #  \u0026lsquo;좀 더 중요하고 큰 다른 것\u0026rsquo;이란 의미. \u0026lsquo;Why did you turn down their offer?\u0026rsquo; \u0026lsquo;Oh, I have bigger fish to fry.\u0026rsquo;\nCan of Worms #  \u0026lsquo;심각한 문제를 초래할 수 있는 위험\u0026rsquo;. \u0026lsquo;What do you think about the new tax law?\u0026rsquo; \u0026lsquo;I think it\u0026rsquo;s opening a can of worms.\u0026rsquo;\nCuriousity kills the cat #  \u0026lsquo;괜한 호기심이 화를 부른다\u0026rsquo;라는 표현. \u0026lsquo;I want to know who\u0026rsquo;s behind the plot.\u0026rsquo; \u0026lsquo;Curiosity kills the cat. Keep that in mind.\u0026rsquo;\nStop and kick every dog that barks at you #  \u0026lsquo;조금이라도 타인이 듣기 싫은 소리하는걸 못참아 하는 것\u0026rsquo;을 의미. \u0026lsquo;Don\u0026rsquo;t stop and kick every dog that barks at you. You are wasting your time\u0026rsquo; \u0026lsquo;I know. I know. But sometimes it really gets on my nerves.\u0026rsquo;\nTry telling me English is easy. #  \u0026lsquo;Try me\u0026rsquo;는 \u0026lsquo;How you dare\u0026rsquo;의 뜻 \u0026ldquo;어디 한번 영어가 쉽다고 말해보시지?\u0026rdquo; 정도.\nEase into #  천천히 들듯이 적응하다는 의미.\nFeel insecure about someone\u0026rsquo;s appearance #  외모에 자신감이 없다는 뜻.\nElbow me in the rib #  옆구리를 쿡쿡 찌른다는 의미.\nBe good at #  ~ 잘하다. \u0026ldquo;I\u0026rsquo;m not good at English.\u0026rdquo;\nStay safe #  항상 조심해. Be Safe. 조심해. 잘지내. 정도.\nI don\u0026rsquo;t want your help to go in vain. #  \u0026ldquo;괜한짓 하지 않으셔도 되요\u0026rdquo; 정도.\nThe mortifying ordeal of being known. #  \u0026ldquo;알려졌다는 수치스러운 그 고통\u0026rdquo;.\nThat\u0026rsquo;s so cheesy! #  오글거린다는 표현\nHe is so lucky his face does it for him when he has an attitude. #  \u0026ldquo;약간 거들먹 거려도 그의 얼굴이 받쳐주니 참 행운아네\u0026rdquo; 정도.\nWhy would you do that?! #  \u0026ldquo;왜 그럴려고 하는데?\u0026ldquo;와 \u0026ldquo;왜 그랬니\u0026rdquo; 정도.\nGod complex #  신 컴플렉스이네요. 자신이 신 또는 메시아라고 믿는 과대망상.\nShe is so catch. #  튕긴다는 표현.\nThe ramen will get mushy and soggy. #  \u0026ldquo;라면 불겠다\u0026quot;는 표현.\nMirror selfie #  전신을 거울로 찍는 셀카.\nShowing off #  생색낸다는 표현.\nBe possessed by a ghost #  귀신들렸다는 표현.\nhigh-maintenance #  손이 많이 간다는 표현.\nI\u0026rsquo;m practicing passive listening while I study the bible. #  성경을 공부하며 흘려듣기로 듣기 연습을 한다.\nKeep your eyes peeled for my message coming soon. #  내가 답장할때까지 눈 똑바로 뜨고 잘보고 있어.\nCheeky #  아주 밉지 않은 얄미운것.\nBath dipper or pail #  손잡이 달린 바가지.\nKeep your bangs #  앞머리 자르지 마\nFolded the paper star #  종이별 접는다\nSpirit animal #  대표 영혼? 롤모델?\nTo call on #  선생님들이 학생들한테 질문을 묻기 위해 부름\nHis research put forth 5 hypotheses. #  그의 연구는 다섯가지의 가설을 제시한다.\nWhat are some cheesy pick-up lines in English? #  영어로 오글거리는 작업멘트 알려주세요.\nSo the most I will do is send a message #  답글 보내는거 이상은 하지 않겠다.\nPiggyback ride #  어부바\nTo knead rice #  쌀을 빚다\nThe power of someone\u0026rsquo;s glasses #  안경 도수\nWhat\u0026rsquo;s with you #  너 왜그러니?\n‎A smile curves up his lips #  그의 입가에 미소가 번졌다.\nThis cleanser is a splurge #  이 클린저는 돈낭비입니다.\nBullshitting #  지랄\nAbbreation Form in messanger #  TY : Thank you\nYW : You\u0026rsquo;re welcome\nTTYL : Talk to you later.\nK : Okay.\nSUP : Wat\u0026rsquo;s UP?\nIK : I know.\nDon\u0026rsquo;t tread on me #  Gadsden flag\nAn unearned win / the game by default #  부전승\nLike I used to #  예전 같은\nFor the life of me #  아무리 생각해봐도\u0026rdquo; I can\u0026rsquo;t remember her name for the life of me.\nShoot the breeze #  수다를 떤다\nShoot one\u0026rsquo;s mouth off #  주절거린다\nI\u0026rsquo;m good #  난 됐어\nDownward spiral #  악순환\nGwak, Blank expression #  Gwaking은 멍한, 얼빠진 표정\nCome over to my place #  우리 집에 놀러와\nOne of the three dog days #  복날\nMaintain composure #  평정심 유지\n"});index.add({'id':23,'href':'/docs/documents/gamedev/','title':"Game Dev",'section':"Documents",'content':"Game Dev #     C   Description   C\u0026#43;\u0026#43;   Description   "});index.add({'id':24,'href':'/posts/201022/','title':"Personal Log",'section':"Blog",'content':" 전체 기록 초기화 진행. 전체 어조 변경 진행. 당 사이트는 개인 기록 용도로 전환. 블로그에서 일자가 과거일 경우 조회가 되지 않는 내용 확인. 블로그 요약 표시는 전반 400자 정도를 추출하여 표시. BOOK 테마 원본 수정 조치 (Summary -\u0026gt; Description 전환)\n 다음글  "});index.add({'id':25,'href':'/posts/200928/','title':"Hello World!",'section':"Blog",'content':" Software Programing Language한 지금까지 다루어 언어는 총 21개 항목. ASP.NET, BASIC, C, C#, C++, Coldfusion, Command Script, CSS, Go, HTML, Java, Javascript, PHP, ProC, Python3, PL/SQL, Rust, SQL, Unix Shell, VBScript. 직무 관련 언어 몇가지를 제외하면 모두를 자유롭게 다루지는 못함. 최근 관심언어는 Rust,Go,Javascript,Python,Web Assembly 등이 있음. 전체적으로는 범용성이 높은 언어를 깊게 가져가기를 희망하나 목표가 불분명해 언어사이를 방황하고 있는 듯한 소견임. 하기 컬렉션 사이트를 참조하여 \u0026lsquo;Hello World\u0026rsquo; 생성 코드 작성하였음.\nhelloworldcollection\nASP.NET #  \u0026lt;%= \u0026#34;Hello World!\u0026#34; %\u0026gt;  언제 : 밀레니엄 즈음\u0026hellip;\n이유 : 개인 홈페이지 제작\u0026hellip;\n BASIC #  10 PRINT \u0026#34;Hello World!\u0026#34;  언제 : 중학교\u0026hellip; 이유 : 텍스트 기반 게임 제작\u0026hellip;\n C (Windows) #  #include \u0026lt;windows.h\u0026gt; int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR CmdLine, int Show) { MessageBox(GetActiveWindw(), \u0026#34;Hello World!\u0026#34;, \u0026#34;Hello Windows\u0026#34;, MB_OK); return 0; }  언제 : 대학교\u0026hellip; 이유 : 윈도우 API 공부\u0026hellip;\n C# #  class HelloWorld { static void Main() { System.Console.WriteLine(\u0026#34;Hello, World!\u0026#34;); } }  언제 : 2009년 5월\u0026hellip;\n이유 : 모델링 툴 제작\u0026hellip;\n C++ (.NET) #  using namespace System; void main() { console::WriteLine(\u0026#34;Hello World!\u0026#34;); }  언제 : 2003년 11월\u0026hellip;\n이유 : 이소메트릭 게임 제작\u0026hellip;\n ColdFusion #  \u0026lt;cfset message = \u0026#34;Hello World!\u0026#34;\u0026gt; \u0026lt;cfoutput\u0026gt; #message# \u0026lt;/cfoutput\u0026gt;  언제 : 석사\u0026hellip;\n이유 : 과제\u0026hellip;\n CommandScript #  echo \u0026#34;Hello World!\u0026#34;  언제 : 가끔\u0026hellip;\n이유 : 파일정리\u0026hellip;\n CSS #  body:before { content: \u0026#34;Hello World!\u0026#34;; }  언제 : 최근\u0026hellip;\n이유 : Frontend 공부\u0026hellip;\n Go #  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello Wrold!\u0026#34;) }  언제 : 최근\u0026hellip;\n이유 : Backend 공부\u0026hellip;\n HTML #  \u0026lt;HTML\u0026gt; \u0026lt;HEAD\u0026gt; \u0026lt;TITLE\u0026gt;Hello World!\u0026lt;TITLE\u0026gt; \u0026lt;/HEAD\u0026gt; \u0026lt;BODY\u0026gt; \u0026lt;H1\u0026gt;Hello World!\u0026lt;/H1\u0026gt; \u0026lt;/BODY\u0026gt; \u0026lt;/HTML\u0026gt;  언제 : 최근\u0026hellip;\n이유 : Frontend 공부\u0026hellip;\n Java #  class HelloWorld { static public void main (String args[]) { System.out.println(\u0026#34;Hello World!\u0026#34;); } }  언제 : 대학교\u0026hellip; 이유 : 학부수업\u0026hellip;\n JavaScript #  console.log(\u0026#34;Hello World!\u0026#34;)  언제 : 최근\u0026hellip;\n이유 : Frontend 공부\u0026hellip;\n PHP #  \u0026lt;?php echo \u0026#39;Hello World!\u0026#39;; ?\u0026gt; 언제 : 대학교\u0026hellip; 이유 : 개인 홈페이지 제작\u0026hellip;\n ProC #  #include \u0026lt;stdio.h\u0026gt;EXEC SQL INCLUDE SQLCA; int main() { char hello[15]; char *user = \u0026#34;user\u0026#34;; char *pass = \u0026#34;password\u0026#34;; char *sid = \u0026#34;the_sid\u0026#34;; EXEC SQL CONNECT :user IDENTIFIED BY :password USING :sid; EXEC SQL SELECT \u0026#39;Hello World!\u0026#34; INTO :hello FROM DUAL; printf(\u0026#34;%s\\n\u0026#34;,hello) EXEC SQL COMMIT RELEASE; return 0; }  언제 : 2005년부터 2010년까지\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n Python3 #  print(\u0026#34;Hello World!\u0026#34;)  언제 : 최근\u0026hellip;\n이유 : 딥러닝 공부\u0026hellip;\n PL/SQL (Oracle) #  begin dbms_output.enable(1000); dbms_output.put_line(\u0026#39;Hello World!\u0026#39;); end;  언제 : 2005년 이후\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n Rust #  fn main () { println!(\u0026#34;Hello World!\u0026#34;); }  언제 : 최근\u0026hellip;\n이유 : Backend 공부\u0026hellip;\n SQL (Oracle) #  select \u0026#39;Hello World\u0026#39; from dual;  언제 : 2005년 이후\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n Unix Shell #  echo Hello World  언제 : 2005년부터 2010년까지\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n VBScript #  MsgBox \u0026#34;Hello world!\u0026#34;  언제 : 2010년부터 2017년까지\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n  다음글  "});})();