'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/','title':"Docs",'section':"Home",'content':"  Documents     "});index.add({'id':1,'href':'/docs/documents/projects/','title':"Projects",'section':"Documents",'content':"Projects #     hU-Go-Girl   HUGO (feat Github)를 이용한 정적 웹페이지 생성   "});index.add({'id':2,'href':'/docs/documents/projects/hugogirl/','title':"hU-Go-Girl",'section':"Projects",'content':"hU-Go-Girl #   관련 내용 및 참고 링크\n Static Web page Hugo Jekyll Github Markdown Buy me a coffee   -- Static vs Dynamic #  정적웹은 사용자의 요청에 대해 준비된 응답만을 제공.\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph LR A[ 사용자 ]--|요청|B[웹서버] B--|응답|A style A fill:#ffffff,stroke:#000000,stroke-width:1px style B fill:#ffffff,stroke:#000000,stroke-width:1px 동적웹은 사용자의 요청을 위해 추가적인 가공을 거쳐 처리.\ngraph LR D[ 사용자 ]--|요청|F[웹서버]--|프로세싱|G[(DB서버)] G--|응답|F--|응답|D style D fill:#ffffff,stroke:#000000,stroke-width:1px style F fill:#ffffff,stroke:#000000,stroke-width:1px style G fill:#ffffff,stroke:#000000,stroke-width:1px 개인 기록 용도로는 동적 서비스가 불필요. 해당 사이트는 정적웹으로 선택.\nGithub #  Git은 리눅스 커널의 소스코드 관리를 위해 리누스 토발즈1가 개발. Git을 위한 무료 저장소 Github. 해당 서비스에는 자료 공유를 위한 Markdown 지원의 웹 호스팅 서비스도 포함.\n Github 가입 Repository 생성 Github Page 설정 Add a README file 포함 Setting \u0026gt; Github Pages \u0026gt; Source 설정  Jekyll vs Hugo #  Jekyll은 Github의 창립자2가 Ruby3라는 언어로 만든 정적 웹 생성기. 별도 빌드 없이 Github와 연동 가능. Hugo는 GO로 작성된 정적 웹 생성기. 유사한 툴로 중국에서 제작된 Hexo도 있음.4 둘다 빠른 빌드를 특징으로 하고 있음.\nJekyll은 테마가 많고 Github에 빌드 없이 연동할 수 있음. 다만 컨텐츠에 따라 빌드 시간이 비례하여 증가5.\nTheme #  문서와 기록이 주 용도로 텍스트 기반의 테마를 검토. Jekyll에서는 Just-the-doc. Hugo에서는 Book 테마. 필요에 따라 몇가지 디자인을 수정.\nMarkdown #  Markdown은 HTML과 같은 마크업 언어임. 마크업 언어는 별도 표현을 위한 기술언어를 의미.\nMarkdown 정리\nBuy Me a Coffee #  개인 컨텐츠 제작자를 위한 후원 서비스 사이트. Buy me a coffee 가입 중 Paypal에 등록하여 방문객이 1$~5$ 소액 송금이 가능.6 커피 아이콘을 커스터마이징하여 사용.\nConclusion #   VSC에서 Markdown을 이용 포스트를 작성 Hugo Build / Sever를 통해 로컬에서 확인 Hugo Public를 통해 Public 빌드 Git을 통해 Github에 Push하고 Web으로 Publish  # 1) Hugo Build 경로를 삭제합니다. rm -rf ./public/ # 2) Hugo Build 합니다. hugo -t book # 3) 전 제 github를 Hugo build 경로 안에 위치 시켰습니다. 해당내용을 .git만 제외하고 삭제하는 내용입니다. find ./youraccount.github.io/ -maxdepth 1 ! -name \u0026#34;.git\u0026#34; ! -name \u0026#34;youraccount.github.io\u0026#34; -exec rm -rf {} \\; # 4) public을 pull한 경로로 옮깁니다. cp -r ./public/* ./youraccount.github.io/ # 5) pull한 경로로 이동합니다. cd ./youraccount.github.io # 6) add / commit / push 합니다. git add . git commit -m \u0026#34;$(date +\u0026#34;%y%m%d_%H:%M\u0026#34;)\u0026#34; git push origin master \nReference #   생활코딩 : 버전관리 시스템 생활코딩 : Github  Footnote #    저명하신 키보드 워리어 \u0026#x21a9;\u0026#xfe0e;\n 톰 프레스톤 워너 \u0026#x21a9;\u0026#xfe0e;\n 일본산 \u0026#x21a9;\u0026#xfe0e;\n 비교자료 \u0026#x21a9;\u0026#xfe0e;\n [Jekyll성능이슈]](https://forestry.io/blog/how-i-reduced-my-jekyll-build-time-by-61/) \u0026#x21a9;\u0026#xfe0e;\n 한국 PayPal FAQs \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':3,'href':'/docs/documents/frontend/','title':"Front End",'section':"Documents",'content':"Front End #     Markdown   Markdown 문법 설명   "});index.add({'id':4,'href':'/docs/documents/frontend/markdown/','title':"Markdown",'section':"Front End",'content':"Markdown #   Markdown은 HTML 변환이 가능한 텍스트 기반 경량 마크업 언어. 특수 기호와 문자를 이용해 쉽게 쓰고 읽을 수 있으며 문법이 비교적 쉽고 간단한 것이 특징.\nHeader #  Markdown # H1 크기 제목입니다. ## H2 크기 제목입니다. ### H3 크기 제목입니다. #### H4 크기 제목입니다. ##### H5 크기 제목입니다. ###### H6 크기 제목입니다. Result H1 크기 제목입니다. H2 크기 제목입니다. H3 크기 제목입니다. H4 크기 제목입니다. H5 크기 제목입니다. H6 크기 제목입니다.  Emphasis #  Markdown *강조 형태 1* _강조 형태 2_ **강조 형태 3** __강조 형태 4__ ~~강조 형태 5~~ Result 강조 형태 1\n강조 형태 2\n강조 형태 3\n강조 형태 4\n강조 형태 5 List #  Markdown 1. 순서 리스트 1 2. 순서 리스트 2 3. 순서 리스트 3 - 리스트 1 - 리스트 2 - 리스트 3 - 리스트 1 - 리스트 1-1 - 리스트 1-1-1 - 리스트 2 - 리스트 2-1 - 리스트 2-1-1 - 리스트 3 - 리스트 3-1 - 리스트 3-1-1 Result  순서 리스트 1 순서 리스트 2 순서 리스트 3   리스트 1 리스트 2 리스트 3 리스트 1  리스트 1-1  리스트 1-1-1     리스트 2  리스트 2-1  리스트 2-1-1     리스트 3  리스트 3-1  리스트 3-1-1       Blockquotes #  Markdown \u0026gt; 인용 1 \u0026gt; 인용 2 \u0026gt; 인용 3 \u0026gt; 인용 1 \u0026gt;\u0026gt; 인용 2 \u0026gt;\u0026gt;\u0026gt; 인용 3 탭) 인용 1 탭) 인용 2 탭) 인용 3 Result  인용 1\n인용 2\n인용 3 인용 1\n 인용 2\u0026gt;\n 인용 3 탭) 인용 1 탭) 인용 2 탭) 인용 3\n    Inline code #  Markdown ```Rust fn main () { println!(\u0026#34;Hello World!\u0026#34;); } ``` \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; { fn main () { println!(\u0026#34;Hello World!\u0026#34;); } } \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; Result fn main () { println!(\u0026#34;Hello World!\u0026#34;); }  { fn main () { println!(\"Hello World!\"); } }   Tables #  Markdown | Header1 | Header2 | Header3 | Header4 | Header5 | | :------ | ------: | :-----: | ------- | ------- | | a | b | c | **d** | ~~e~~ | | f | g | h | i | j | | k | l | m | n | o | Result    Header1 Header2 Header3 Header4 Header5     a b c d e   f g h i j   k l m n o     Checkbox #  Markdown 1. [ ] To-Do 1 2. [x] To-Do 2 - [ ] To-Do 3 - [x] To-Do 4 Result  To-Do 1 To-Do 2   To-Do 3 To-Do 4   Hyperlinks #  Markdown [Prokoptasis](https://prokoptasis.github.io/docs/documents/frontend/markdown/) Result Prokoptasis Images #  Markdown ![coffee](../../../../../coffee.jpg) [![coffee](../../../../../coffee.jpg)](https://prokoptasis.github.io/docs/documents/frontend/markdown/) Result  Iframe #  Markdown \u0026lt;iframe width=\u0026#34;100%\u0026#34; height=\u0026#34;400px\u0026#34; src=\u0026#34;https://www.youtube.com/embed/4Vs25c7dzTQ\u0026#34; frameborder=\u0026#34;0\u0026#34; allow=\u0026#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen\u0026gt;\u0026lt;/iframe\u0026gt; Result   Etc #  Markdown 라인1 *** 라인2 --- 라인3 ___ 라인4 \u0026lt;hr\u0026gt; 문장 1 \u0026lt;br\u0026gt; 문장 2 (공백3칸) 문장 3 (공백없음) 문장 4 \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;가운데 정렬\u0026lt;/div\u0026gt; \u0026lt;span style=\u0026#34;color:red\u0026#34;\u0026gt;빨\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#0055FF\u0026#34;\u0026gt;파\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:rgb(21, 250, 16)\u0026#34;\u0026gt;녹\u0026lt;/span\u0026gt; Result 라인1\n 라인2\n 라인3\n 라인4\n 문장 1 문장 2 (공백3칸) 문장 3 (공백없음) 문장 4 가운데 정렬 빨 파 녹  Footnotes #  각주[^1] 각주1\n  각주입니다. \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':5,'href':'/docs/documents/backend/','title':"Back End",'section':"Documents",'content':"Back End #     Rust   Rust Language Study   Go   Go Language Study   SQL   SQL 문법 설명   "});index.add({'id':6,'href':'/docs/documents/backend/rust/','title':"Rust",'section':"Back End",'content':"RUST #     Rust Basic 01   Rust Basic 01   Rust Basic 02   Rust Basic 02   "});index.add({'id':7,'href':'/docs/documents/backend/go/','title':"Go",'section':"Back End",'content':"GO #     GO Basic 1   GO Basic 1   GO Basic 2   GO Basic 2   "});index.add({'id':8,'href':'/docs/documents/backend/sql/','title':"SQL",'section':"Back End",'content':"SQL #     SQL Basic 1   SQL Basic Query 1   SQL Basic 2   SQL Basic Query 2   SQL Basic 3   SQL Basic Query 3   "});index.add({'id':9,'href':'/docs/documents/backend/sql/sql01/','title':"SQL Basic 1",'section':"SQL",'content':"SQL Basic 1 #   SQL은 Sturctured Query Langugage의 약자로 데이터베이스의 데이터를 관리하기 위해 사용하는 언어. 자료의 검색과 관리, 스키마의 생성과 수정, 객체의 접근 조정 및 관리의 기능 제공. ANSI SQL 기본 문법은 원래 어떤 데이터베이스와도 호환이 가능해야 하나 통상 Vendor들이 표준을 잘지키지않는 편이라 기본적인 수준에서만 호환이 가능. NoSQL 계열의 데이터베이스에서는 사용되지 않음. (다음은 오라클 기준임)\nLive SQL #   Oracle 가입 Oracle Live SQL 접속 \u0026ldquo;Start Coding Now\u0026rdquo; Live SQL 실행  Hello World! #  select \u0026#39;Hello World!\u0026#39; from dual; DDL / DML / DCL #  조회를 위한 예제 테이블이 작성을 위해 DDL, DML, DCL 개념 필요.\nDDL (Data Definition Language) #  데이터 정의 언어로 데이터베이스에 오브젝트를 생성,삭제,변경 및 제거하는 명령문\ncreate : 데이터베이스에 오브젝트를 생성 drop : 데이터베이스에 오브젝트를 삭제 alter : 데이터베이스에 오브젝트를 변경 truncate : 테이블에서 데이터를 삭제\nDML (Data Manipulation Languge) #  데디터 조작 언어로 데이터베이스 테이블에서 데이터를 질의,생성,수정 및 삭제하는 질의문\nselect : 테이블에서 데이터를 검색 insert : 테이블에 데이터를 생성 update : 테이블에서 데이터를 변경 delete : 데이블에서 데이터를 삭제\nDCL (Data Control Language) #  데이터 제어 언어로 데이터베이스의 권한을 관리하는데 사용하는 명령문\ngrant : 데이터베이스 사용자에게 특정 권한을 부여 revoke : 데이터베이스 사용자에게 특정 권한을 제거\nTable Creation #  작성쿼리 create table my_table_1 ( column_1 varchar2(10), column_2 number, column_3 date ) ; insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;홍길동\u0026#39;,23,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;김철수\u0026#39;,19,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;이영희\u0026#39;,32,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;박민호\u0026#39;,22,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;김종철\u0026#39;,45,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;김철수\u0026#39;,36,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;신영희\u0026#39;,32,sysdate); insert into my_table_1 (column_1,column_2,column_3) values (\u0026#39;최철호\u0026#39;,11,sysdate); 실행결과 Table created.\n1 row(s) inserted.\n1 row(s) inserted.\n1 row(s) inserted.\n1 row(s) inserted.\n1 row(s) inserted.\n1 row(s) inserted.\n1 row(s) inserted.\n1 row(s) inserted.\n 데이터 생성 결과를 조회\n작성쿼리 select * from my_table_1 ; 실행결과    COLUMN_1 COLUMN_2 COLUMN_3     홍길동 23 10-OCT-20   김철수 19 10-OCT-20   이영희 32 10-OCT-20   박민호 22 10-OCT-20   김종철 45 10-OCT-20   김철수 36 10-OCT-20   신영희 32 10-OCT-20   최철민 11 10-OCT-20    Download CSV 8 rows selected.  다음글  "});index.add({'id':10,'href':'/docs/documents/backend/sql/sql02/','title':"SQL Basic 2",'section':"SQL",'content':"SQL Basic 2 #   Select, Where, 기본적인 함수, Union, Join\nSelect / From #   select / from ...  -- 주석입니다. select * from my_table_1; -- 컬럼명을 지정합니다. select column_1,column_3 from my_table_1;     Where / And #   where / and ...  -- where select * from my_table_1 where column_2 = 32; -- where / 부등호 1 select * from my_table_1 where column_2 \u0026lt;= 30; -- where / 부등호 2 select * from my_table_1 where column_2 \u0026gt;= 30; -- where / 부등호 3 select * from my_table_1 where column_2 \u0026gt; 30; -- where / 부등호 4 select * from my_table_1 where column_2 \u0026lt; 30; -- where / and select * from my_table_1 where column_2 \u0026gt; 10 and column_2 \u0026lt; 40; -- where / and / 문자열 1 select * from my_table_1 where column_1 = \u0026#39;홍길동\u0026#39; and column 2 = 23; -- where / and / 문자열 2 select * from my_table_1 where column_1 != \u0026#39;홍길동\u0026#39;; -- where / and / 문자열 3 select * from my_table_1 where column_1 \u0026lt;\u0026gt; \u0026#39;홍길동\u0026#39;; -- where / and / 문자열 / like 1 select * from my_table_1 where column_1 like \u0026#39;김%\u0026#39;; -- where / and / 문자열 / like 2 select * from my_table_1 where column_1 like \u0026#39;%철%\u0026#39;; -- where / and / 문자열 / like 3 select * from my_table_1 where column_1 like \u0026#39;%철\u0026#39;; -- where / and / 문자열 / like 4 select * from my_table_1 where column_1 like \u0026#39;김%철\u0026#39;; -- where / and / 문자열 / like 5 select * from my_table_1 where column_1 not like \u0026#39;%철\u0026#39;; -- where / and / between select * from my_table_1 where column_2 between 22 and 32; -- where / and / in select * from my_table_1 where column_1 in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;); -- where / and / not in select * from my_table_1 where column_1 not in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;); -- where / and / in / or select * from my_table_1 where column_1 in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;) or column_2 = 22; -- where / and / or / and 1 select * from my_table_1 where column_1 in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;) or column_2 = 22 and column_1 like \u0026#39;%수\u0026#39;; -- where / and / or / and 2 select * from my_table_1 where (column_1 in (\u0026#39;이영희\u0026#39;,\u0026#39;김철수\u0026#39;) or column_2 = 22) and column_1 like \u0026#39;%수\u0026#39;;     dual / + - * / #   dual / operatios ...  -- dual / + - * / select 2+3, 5-2, 2*3, 8/2 from dual; -- mod, power, sign, cos, tan select mod(7,3),power(2,3),sign(1),cos(1),tan(1) from dual; -- number, text, null, number+null, date select 1, \u0026#39;TEXT\u0026#39;, null, 10+2+null, sysdate from dual; -- number+null = null select 10+2+null from dual; -- number+text(number) = number select 10+2+\u0026#39;3\u0026#39; from dual; -- number+text : error select 10+2+\u0026#39;A\u0026#39; from dual; -- lower/upper select \u0026#39;Case\u0026#39;,lower(\u0026#39;Case\u0026#39;),upper(\u0026#39;Case\u0026#39;) from dual;     count / ditinct / alias / lower / upper #   count / ditinct / alias / lower / upper ...  -- count select count(*) from my_table_1; -- distinct select distinct column_1 from my_table_1; -- distinct / count select count(distinct column_1),count(column_1) from my_table_1; -- distinct / count / alias select count(distinct column_1) col1,count(column_1) col2,count(tab.column_1) col3 from my_table_1 tab;     from / nested from / with as #   from / nested from / with as ...  -- from 1 select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ; -- nested from select * from ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ) ; -- with 1 with tab_1 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ) select * from tab_1 ; -- with 2 with tab_1 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ) , tab_2 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30 ) select * from tab_2 ; -- with 3 with tab_1 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;) ) , tab_2 as ( select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30 ) select * from ( select * from tab_2 where column_1 like \u0026#39;%철%\u0026#39; ) ;     union all / union / intersect / minus #   union all / union / intersect / minus ...  -- union all with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 union all select * from tab_2 ; -- union with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 union all select * from tab_2 ; -- intersect with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 intersect select * from tab_2 ; -- minus with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 intersect select * from tab_2 ;     join 1 / join 2 / join 3 / join 4 / join 5 #   join ...  -- join 1 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a, tab_2 b where a.column_1 = b.column_1 ; -- join 2 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a, tab_2 b where a.column_1 = b.column_1 and a.column_2 = b.column_2 ; -- join 3 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a, tab_2 b where a.column_1 = b.column_1 (+) and a.column_2 = b.column_2 (+) ; -- join 4 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a, tab_2 b where a.column_1 (+) = b.column_1 and a.column_2 (+) = b.column_2 ; -- join 5 with tab_1 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_1 in (\u0026#39;홍길동\u0026#39;,\u0026#39;김철수\u0026#39;,\u0026#39;이영희\u0026#39;)) , tab_2 as (select column_1,column_2,column_2+10 column_3 from my_table_1 where column_2 \u0026lt;= 30) select * from tab_1 a full outer join tab_2 b on ( a.column_1 = b.column_1 and a.column_2 = b.column_2 ) ;      다음글  "});index.add({'id':11,'href':'/docs/documents/backend/sql/sql03/','title':"SQL Basic 3",'section':"SQL",'content':"SQL Basic 3 #   작성중\n 다음글  "});index.add({'id':12,'href':'/docs/documents/backend/go/go01/','title':"GO Basic 1",'section':"Go",'content':"GO Basic 1 #   Go 기본적인 문법 정리. 하기 사이트 참조.\n예제로 배우는 Go 프로그래밍\nHello World #  package main func main() { println(\u0026#34;Hello World!\u0026#34;) } Declare #  선언 및 할당 방식\n Declare ...  package main func main() { // 선언 및 할당 \tvar a int var b float32 = 11. println(a, b) // 선언 및 할당 \ta = 10 b = 12.0 println(a, b) // 상수 \tconst c int = 10 const d string = \u0026#34;Hello\u0026#34; println(c, d) // 상수 나열 \tconst ( Visa = \u0026#34;Visa\u0026#34; Master = \u0026#34;MasterCard\u0026#34; Amex = \u0026#34;American Express\u0026#34; ) println(Visa, Master, Amex) // 상수 나열 \tconst ( Apple = iota Grape Orage ) println(Apple, Grape, Orage) }     Reserved Keywords #  GO 25개 예약어\nbreak, case, chan, const, continue, const, default, const, defer, else,fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var  Declaration of Varialbe and Operators #  변수 선언 및 연산자\n Declaration of Varialbe ...  func main() { textLine1 := `첫번째 줄입니다.\\n 두번째 줄입니다.\\n 세번째 줄입니다` fmt.Println(textLine1) textLine2 := \u0026#34;첫번째 줄입니다.\\n두번째 줄입니다.\\n세번째 줄입니다\u0026#34; fmt.Println(textLine2) textLine3 := \u0026#34;첫번째 줄입니다.\\n\u0026#34; + \u0026#34;두번째 줄입니다.\\n\u0026#34; + \u0026#34;세번째 줄입니다\u0026#34; fmt.Println(textLine3) var a int = 100 var b uint = uint(a) var c float32 = float32(a) println(a, b, c) str := \u0026#34;ABCDEFG\u0026#34; byt := []byte(str) stg := string(byt) println(str, byt, byt[0], byt[1], stg) }      Operators ...  package main func main() { var a int = 7 var b int = 3 //산술연산자 \tvar c = (a + b) / 5 println(a, b, c) c++ println(c) // 관계연산자 \tif b == c { println(\u0026#34;b==c\u0026#34;) } else { println(\u0026#34;b!=c\u0026#34;) } if a != b { println(\u0026#34;a!=b\u0026#34;) } else { println(\u0026#34;a==b\u0026#34;) } if a \u0026gt;= b { println(\u0026#34;a\u0026gt;=b\u0026#34;) } else { println(\u0026#34;a\u0026lt; b\u0026#34;) } // 논리 연산자 \tif a \u0026gt;= b \u0026amp;\u0026amp; b == c { println(\u0026#34;a\u0026gt;=b \u0026amp;\u0026amp; b==c\u0026#34;) } else { println(\u0026#34;not(a\u0026gt;=b \u0026amp;\u0026amp; b==c)\u0026#34;) } if a \u0026gt;= b || b \u0026gt; c { println(\u0026#34;a\u0026gt;=b || b\u0026lt;\u0026gt;c\u0026#34;) } else { println(\u0026#34;not(a\u0026gt;=b || b\u0026lt;\u0026gt;c)\u0026#34;) } // Bitwise 연산자 \tvar d = (a \u0026amp; b) var e = (a \u0026amp; b) \u0026lt;\u0026lt; 1 println(d, e) // 할당연산자 \ta = 10 println(a) a *= 10 println(a) a \u0026gt;\u0026gt;= 1 println(a) a |= 1 println(a) // 포인터 연산자 \tvar x int = 10 var p = \u0026amp;x //x\u0026#39;s address  // x = value \t// \u0026amp;x = x\u0026#39;s address \t// p = \u0026amp;x = x\u0026#39;s address \t// *p = x\u0026#39;s address\u0026#39;s value \t// \u0026amp;p = p\u0026#39;s address \tprintln(x, \u0026amp;x, p, *p, \u0026amp;p) x++ println(x, \u0026amp;x, p, *p, \u0026amp;p) }     Conditional Statement #   Conditional Statement ...  package main func main() { var a = 1 if a == 1 { println(\u0026#34;One\u0026#34;) } else if a == 2 { println(\u0026#34;Two\u0026#34;) } else { println(\u0026#34;Other\u0026#34;) } // Optional Statement \tif b := 1; b \u0026lt; 10 { println(b) } var name string var category = 1 switch category { case 1: name = \u0026#34;Paper Book\u0026#34; case 2: name = \u0026#34;eBook\u0026#34; case 3, 4: name = \u0026#34;Blog\u0026#34; default: name = \u0026#34;Other\u0026#34; } println(name) // Expression을 사용한 경우 \tswitch x := category \u0026lt;\u0026lt; 2; x - 1 { //... \t} var score = 80 switch { case score \u0026gt;= 90: println(\u0026#34;A\u0026#34;) case score \u0026gt;= 80: println(\u0026#34;B\u0026#34;) case score \u0026gt;= 70: println(\u0026#34;C\u0026#34;) case score \u0026gt;= 60: println(\u0026#34;D\u0026#34;) default: println(\u0026#34;No Hope\u0026#34;) } }     Iteration #   Iteration ...  package main func main() { sum := 0 for i := 1; i \u0026lt;= 100; i++ { sum += i } println(sum) n := 2 for n \u0026lt; 100 { n = n * n } println(n) names := []string{\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;geh\u0026#34;} for index, name := range names { println(index, name) } b := 0 L1: for { if b == 0 { break L1 } } println(\u0026#34;L1\u0026#34;, b) var a = 1 for a \u0026lt; 15 { if a == 5 { a += 4 continue } a++ println(\u0026#34;In\u0026#34;, a) if a \u0026gt; 9 { println(\u0026#34;Here\u0026#34;, a) break } } if a == 11 { goto END } println(a) END: println(\u0026#34;End\u0026#34;, a) }     \u0026lsquo;goto END\u0026rsquo;는 END 레이블로 이동 \u0026lsquo;break L1\u0026rsquo;은 break 레이블로 위치를 이동.\nMethod #   Method ...  package main func main() { msg := \u0026#34;Hello\u0026#34; // Function \tsay(msg) println(\u0026#34;2\u0026#34;, msg) // Pass By Reference \tsayC(\u0026amp;msg) println(\u0026#34;4\u0026#34;, msg) // Variadic Function \tsayV(\u0026#34;this\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;pen\u0026#34;) sayV(\u0026#34;and\u0026#34;, \u0026#34;pineapple\u0026#34;) // Return Value \ttotal := sum(1, 7, 3, 5, 9) println(total) // Return Multiple Value \tcount, total := sumC(1, 7, 3, 5, 9) println(count, total) // Named Return Parameter \tcount, total = sumN(1, 7, 3, 5, 9) println(\u0026#34;Named Return Param\u0026#34;, count, total) // Anonymous Function \tsumA := func(n ...int) int { //익명함수 정의 \ts := 0 for _, i := range n { s += i } return s } result := sumA(1, 2, 3, 4, 5) println(\u0026#34;result :\u0026#34;, result) // add anonymouse function \tadd := func(i int, j int) int { return i + j } // send anonumous function to other function \tr1 := calc(add, 10, 20) println(\u0026#34;r1 :\u0026#34;, r1) // directly \tr2 := calc(func(x int, y int) int { return x - y }, 10, 20) println(\u0026#34;r2 :\u0026#34;, r2) // prototype function \tr3 := calcP(add, 10, 25) println(\u0026#34;r3 :\u0026#34;, r3) // closure \tnext1 := nextValue() println(\u0026#34;next1\u0026#34;, next1()) println(\u0026#34;next1\u0026#34;, next1()) println(\u0026#34;next1\u0026#34;, next1()) next2 := nextValue() println(\u0026#34;next2\u0026#34;, next2()) println(\u0026#34;next2\u0026#34;, next2()) println(\u0026#34;next1\u0026#34;, next1()) } func say(msg string) { println(\u0026#34;1\u0026#34;, msg) } func sayC(msg *string) { println(\u0026#34;3\u0026#34;, *msg) *msg = \u0026#34;World\u0026#34; } func sayV(msg ...string) { for _, s := range msg { println(s) } } func sum(nums ...int) int { s := 0 for _, n := range nums { s += n } return s } func sumC(nums ...int) (int, int) { s := 0 count := 0 for _, n := range nums { s += n count++ } return count, s } func sumN(nums ...int) (count int, total int) { for _, n := range nums { total += n } count = len(nums) return } func calc(f func(int, int) int, a int, b int) int { result := f(a, b) return result } // prototype type calculator func(int, int) int // use prototype function func calcP(f calculator, a int, b int) int { result := f(a, b) return result } // closure func nextValue() func() int { i := 0 return func() int { i++ return i } }     Array, Slice #   Array and Slice ...  package main import \u0026#34;fmt\u0026#34; func main() { // Array \tvar arr1 [3]int arr1[0] = 1 arr1[1] = 2 arr1[2] = 3 println(\u0026#34;arr1[0] : \u0026#34;, arr1[0], \u0026#34;arr1[1] : \u0026#34;, arr1[1], \u0026#34;arr1[2] : \u0026#34;, arr1[2]) var arr2 = [3]int{4, 5, 6} var arr3 = [...]int{7, 8, 9} println(\u0026#34;arr2[0] : \u0026#34;, arr2[0], \u0026#34;arr2[1] : \u0026#34;, arr2[1], \u0026#34;arr2[2] : \u0026#34;, arr2[2]) println(\u0026#34;arr3[0] : \u0026#34;, arr3[0], \u0026#34;arr3[1] : \u0026#34;, arr3[1], \u0026#34;arr3[2] : \u0026#34;, arr3[2]) // multi array 1 \tvar arr4 [3][4][5]int arr4[0][1][2] = 10 println(\u0026#34;arr4[0][1][2] : \u0026#34;, arr4[0][1][2]) // multi array 2 \tvar arr5 = [2][3]int{{1, 2, 3}, {4, 5, 6}} println(\u0026#34;arr5[1][2] : \u0026#34;, arr5[1][2]) // Slice \tvar slc1 []int slc1 = []int{1, 2, 3} slc1[1] = 10 fmt.Println(\u0026#34;slc1 : \u0026#34;, slc1) // Slice with Make \tslc2 := make([]int, 5, 10) println(len(slc2), cap(slc2)) fmt.Println(slc2) // Nil Slice \tvar slc3 []int if slc3 == nil { println(\u0026#34;Nil Slice\u0026#34;) } println(len(slc3), cap(slc3)) fmt.Println(slc3) // Sub Slice \tslc4 := []int{0, 1, 2, 3, 4, 5} fmt.Println(\u0026#34;[0:1] : \u0026#34;, slc4[0:1], \u0026#34;,[2:5] : \u0026#34;, slc4[2:5], \u0026#34;,[1:] : \u0026#34;, slc4[1:], \u0026#34;,[:5] : \u0026#34;, slc4[:5]) // Slice append / copy \tslc5 := []int{0, 1} // append one \tslc5 = append(slc5, 2) // append multiple \tslc5 = append(slc5, 3, 4, 5) fmt.Println(slc5) // Underlying array \tslc6 := make([]int, 0, 3) for i := 1; i \u0026lt; 15; i++ { slc6 = append(slc6, i) fmt.Println(\u0026#34;slc6 len, cap : \u0026#34;, len(slc6), cap(slc6)) } fmt.Println(slc6) // append slice \u0026amp; ellipsis(...) \tslc7 := []int{1, 2, 3} slc8 := []int{4, 5, 6} slc7 = append(slc7, slc8...) fmt.Println(slc7) // slice copy \tslc9 := []int{0, 1, 2} slc10 := make([]int, len(slc9), cap(slc9)*2) copy(slc10, slc9) fmt.Println(slc10) println(len(slc10), cap(slc10)) }      다음글  "});index.add({'id':13,'href':'/docs/documents/backend/go/go02/','title':"GO Basic 2",'section':"Go",'content':"GO Basic 2 #   정리중\n 다음글  "});index.add({'id':14,'href':'/docs/documents/backend/rust/rust01/','title':"Rust Basic 01",'section':"Rust",'content':"Rust Basic 1 #   Rust는 시스템 레벨의 프로그래밍 언어. C/C++의 대체 언어의 특성. 타입 안전성, 메모리 안전성, 동시성, 그리고 성능에도 초점을 맞추어 대규모, 고성능 소프트웨어의 개발을 작성하도록 설계됨. 무효한 메모리 접근을 예방하기 위해 빌림 검사와 같은 독특한 특성을 지님.\n하기 링크 참조.\nThe Rust Programming Language The Rust Programming Language (KOR)\nHello World #  Hello World\ncargo init rust_hello --bin cd rust_hello cargo run fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } Guessing Game #   Source ...  extern crate rand; use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { // 첫 줄 출력 \tprintln!(\u0026#34;Guess the number!\u0026#34;); // 1 부터 100까지의 숫자를 Rangdom으로 생성 후 secret_nmber로 선언  let secret_number = rand::thread_rng().gen_range(1, 101); loop { // 질문 출력  println!(\u0026#34;Please input your guess.\u0026#34;); // guess를 mutable 형태의 string으로 생성  let mut guess = String::new(); // guess의 입력을 받음  io::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026#34;Failed to read line\u0026#34;); // guess를 trim하고 숫자로 전환  let guess: u32 = match guess.trim().parse() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; continue, }; // 사용자의 guess를 재출력  println!(\u0026#34;You guessed: {}\u0026#34;, guess); // secret_number의 숫자를 비교하여 결과를 출력  match guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026#34;Too small!\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;Too big!\u0026#34;), Ordering::Equal =\u0026gt; { println!(\u0026#34;You win!\u0026#34;); break; } } } }     let foo = 5;\t// immutable let mut bar = 5;\t// mutable let baz = String::new(); 기본적으로 let과 let mut은 변수의 가변성에 차이를 두고 다르게 선언하는 것을 의미.String::new는 String타입의 연관함수로 OO에서 클래스의 인스턴스 없이 호출할 수 있는 정적 메소드와 동일.\nio::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026#34;Failed to read line\u0026#34;); 프로그램의 시작점에 \u0026lsquo;use std::io\u0026rsquo;로 명시되었기 때문에 함수 호출시의 io::stdin은 표준 입력 핸들 타입인 std::io::Stdin을 돌려줌. \u0026amp;mut guess를 넘겨받아 사용자의 입력을 저장하게 됨. 이때 사용자의 입력은 지속적으로 추가됨으로 가변 문자열이어야 함. 이때 \u0026lsquo;\u0026amp;mut\u0026rsquo; 인 이유는 Rust에서는 \u0026lsquo;\u0026amp;\u0026rsquo; c참조자의 기본 속성이 안전성을 위해 Immutable임으로 명시적으로 가변임을 지정할 필요가 있음. \u0026lsquo;.expect\u0026rsquo; 는 에러를 처리하는 메소드로 인스터스가 Error를 낼 경우 해당 메세지를 출력하며 동작을 멈추게 됨. 만일 \u0026lsquo;expec\u0026rsquo;없이 컴파일 한다면 경고가 표시됨.\n// place holder println!(\u0026#34;You guessed: {}\u0026#34;, guess); // place holder 지정 println!(\u0026#34;You guessed: {g} number {n}\u0026#34;, g= guess,n = number); 위 문장에서 \u0026lsquo;{}\u0026rsquo; 부분은 변경자(Place Holder)로 guess의 표시 위치를 나타냄. 하나 이상의 Place Holder를 아래처럼 지정하여 사용할 수도 있음.\n// Cargo.toml [dependencies] rand = \u0026#34;0.4.0\u0026#34; Random 처리를 위해 Cargo.toml에 의존성을 추가하여 rand crate를 명시함.\nmatch guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026#34;Too small!\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;Too big!\u0026#34;), Ordering::Equal =\u0026gt; { println!(\u0026#34;You win!\u0026#34;); break; } 사용자가 입력한 guess 숫자와 Random으로 생성된 secret_number를 비교하는 메소드. std 표준 라이브러리로부터 std::cmp::Ordering Scope를 가져와서 Ordering 타입을 사용하는 형태.\nlet guess: u32 = match guess.trim().parse() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; continue, }; 입력된 guess의 문자열을 secret_number와 비교하기 위해 숫자로 바꾸는 라인. 기존 guess 변수를 triming된 숫자로 Shadowing하여 재사용하는 방식으로 구현됨. \u0026lsquo;guess.trim()\u0026lsquo;을 통해 사용자 입력시 들어온 Enter의 개행문자를 제거하고 \u0026lsquo;parse()\u0026lsquo;를 통해 숫자열로 파싱. 이때 u32와 같이 정확한 타입을 명시해야함. 사용자가 입력한 숫자에 특수문자 같은 것이 포함되어 u32로 전환할 수 없을 경우를 대비해서 expect와 같은 별도 처리가 필요할 수도 있음. 여기서는 Error가 들어올경우 continue를 통해 다음 Loop로 다시 시작되도록 처리 됨.\nloop { ... match guess.cmp(\u0026amp;secret_number) { ... Ordering::Equal =\u0026gt; { println!(\u0026#34;You win!\u0026#34;); break; } } main 프로그램은 Ordering::Equal이 나올때까지 Loop로 들어가 반복되며 수행됨.\nCommon Programming Concepts #  Variables / Mutability / Data Types\n variables / mutability / data types ...  fn main() { // immutable  let x = 5; println!(\u0026#34;The value of x is: {}\u0026#34;, x); // x = 7; // connot assign twice to immutable variable  println!(\u0026#34;The value of x is: {}\u0026#34;, x); // shadowing  let x = 10; println!(\u0026#34;The value of x is: {}\u0026#34;, x); // shadowing 2  let spaces = \u0026#34; \u0026#34;; println!(\u0026#34;Spaces: {}\u0026#34;, spaces); let spaces = spaces.len(); println!(\u0026#34;Spaces: {}\u0026#34;, spaces); // mutable  let mut x = 6; println!(\u0026#34;The value of x is: {}\u0026#34;, x); x = 7; // connot assign twice to immutable variable  println!(\u0026#34;The value of x is: {}\u0026#34;, x); // mutable  let mut spaces = \u0026#34; \u0026#34;; println!(\u0026#34;Spaces: {}\u0026#34;, spaces); // spaces = spaces.len(); //expected `\u0026amp;str`, found `usize`  println!(\u0026#34;Spaces: {}\u0026#34;, spaces); // const  const MAX_POINTS: u32 = 100_000; println!(\u0026#34;MAX_POINTS: {}\u0026#34;, MAX_POINTS); // let guess = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); // consider giving `guess` a type  let guess: u32 = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); // float  let f1: f64 = 2.0; let f2: f32 = 3.0; println!(\u0026#34;{},{}\u0026#34;, f1, f2); // let addition  let sum = 5 + 10; // let subtraction  let difference = 95.5 - 4.3; // let multiplication  let product = 4 * 30; // let division  let quotient = 56.7 / 32.2; // let remainder  let remainder = 43 % 5; println!( \u0026#34;let calc {},{},{},{},{}\u0026#34;, sum, difference, product, quotient, remainder ); // boolean  let t = true; let f: bool = false; println!(\u0026#34;let bool {},{}\u0026#34;, t, f); // character  let c = \u0026#39;z\u0026#39;; let z = \u0026#39;ℤ\u0026#39;; let cat = \u0026#39;😻\u0026#39;; println!(\u0026#34;let char {},{},{}\u0026#34;, c, z, cat); // tuple  let tup: (i32, f64, u8) = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026#34;x : {}, y : {}, z : {}\u0026#34;, x, y, z); let x: (i32, f64, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8) = (500, 6.4, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11); let five_hundred = x.0; println!(\u0026#34;five_hundred : {}, x11 : {}\u0026#34;, five_hundred, x.11); // Array  let ary = [1, 2, 3, 4, 5]; let mon = [ \u0026#34;Jan\u0026#34;, \u0026#34;Feb\u0026#34;, \u0026#34;Mar\u0026#34;, \u0026#34;Apr\u0026#34;, \u0026#34;May\u0026#34;, \u0026#34;Jun\u0026#34;, \u0026#34;Jul\u0026#34;, \u0026#34;Aug\u0026#34;, \u0026#34;Sep\u0026#34;, \u0026#34;Oct\u0026#34;, \u0026#34;Nov\u0026#34;, \u0026#34;Dec\u0026#34;, ]; let index = 4; // let index = 12; // panicked at \u0026#39;index out of bounds: the len is 12 but the index is 12\u0026#39;  let frst = ary[0]; let scnd = mon[1]; let thrd = mon[index]; println!(\u0026#34;frst : {} , scnd : {} , thrd : {}\u0026#34;, frst, scnd, thrd); }     Functions\n functions ...  fn main() { println!(\u0026#34;Hello, world!\u0026#34;); // function  function_a(); // function parameter  function_b(3); // function parameters  function_c(3, 5); // statement  let stmt1 = 6; println!(\u0026#34;stmt1 : {}\u0026#34;, stmt1); // let stmt1 = (let stmt2 = 5); // variable declaration using `let` is a statement  let stmt1 = 5; // expression  let stmt2 = { let stmt1 = 3; stmt1 + 1 }; println!(\u0026#34;stmt1 : {}, stmt2 : {}\u0026#34;, stmt1, stmt2); // function with return values  let stmt3 = function_d(); println!(\u0026#34;stmt3 : {}\u0026#34;, stmt3); // function with return values  let stmt4 = function_e(5); println!(\u0026#34;stmt4 : {}\u0026#34;, stmt4); } fn function_a() { println!(\u0026#34;Hello, again!\u0026#34;) } fn function_b(x: i32) { for i in 0..x { println!(\u0026#34;{} : Hello, again!\u0026#34;, i) } } fn function_c(x: i32, y: i32) { for i in x..y { println!(\u0026#34;{}: Hello, again! {},{}\u0026#34;, i, x, y) } } fn function_d() -\u0026gt; i32 { 5 } fn function_e(x: i32) -\u0026gt; i32 { // without semicolon  x + 1 }      다음글  "});index.add({'id':15,'href':'/docs/documents/backend/rust/rust02/','title':"Rust Basic 02",'section':"Rust",'content':"Rust Basic2 #   직성중.\n 다음글  "});index.add({'id':16,'href':'/docs/documents/devops/','title':"Dev ops",'section':"Documents",'content':"Dev ops #     Oracle   Description   Synology   Description   Ubuntu   Description   Docker   Description   AWS   Description   "});index.add({'id':17,'href':'/docs/documents/deeplearning/','title':"Deep Learning",'section':"Documents",'content':"Deep Learning #     Machine Learning   머신러닝/딥러닝 학습 자료   Tensorflow   Description   "});index.add({'id':18,'href':'/docs/documents/deeplearning/machinelearning/','title':"Machine Learning",'section':"Deep Learning",'content':"Machine Learning #   머신 러닝 관련 자료 정리\nMachine Learning 분류 #  머신 러닝은 지도학습, 비지도학습, 강화학습으로 분류. 지도학습은 다시 회귀와 분류, 비지도 학습은 군집화,변환,연관으로 분류1.\n Supervised Learning  Regression Classification   Unsupervised Learning  Clustering Transform Association   Reinforcement Learning  Linear Regression2 #  Regression이란 전체의 평균으로 회귀하려는 속성을 나타냄. 데이터의 분포를 가장 잘 설명 할 수 있는 직선의 방정식을 찾아내는 것을 의미.\n  --  Linear Regression ...   H(X) = WX+B ( y = ax + b ) H : Hypothesis (가설) W : Weight (기울기) B : Bias (절변)     Cost는 데이터와 직선 차이의 합. 음수, 양수 모두 존재함으로 제곱을 사용.\n  --  Cost ...   Cost :   \\( H(x) - y \\)  Total Cost :  \\( \\frac{(H(x_1)-y_1)^2 \u0026#43; (H(x_2)-y_2)^2 \u0026#43; ... \u0026#43; (H(x_n)-y_n)^2 }{n} \\)  Total Cost : cost(W) =  \\( \\frac{1}{n}\\, \\textstyle\\sum_{i=1}^n \\,(Wx_i-y)^2 \\)  Cost Function : cost(W,b) =  \\( \\frac{1}{n}\\, \\textstyle\\sum_{i=1}^n \\,(H(x_i)-y_i)^2 \\)  Goal : minimize_w,_b cost(W,b)     Goal은 가설과 실제 데이터 차이의 제곱이 최소가 되는 기울기와 절편은 찾는 문제.\nGradient Descent #  임의 점에서 시작 학습률 만큼 기울기가 낮은 쪽으로 진행하며 최적해를 탐색하는 방식을 경사하강법이라 함. Convext 상황에서는 잘 작동하나 Local Optimal이 존재할 경우 문제가 발생됨3.\n  --  Gradient Descent ...    \\( W := W - \\alpha \\frac{\\partial}{\\partial W} \\, \\frac{1}{2m} \\textstyle\\sum_{i=1}^m (W(x_i)-y_i)^2 \\)   \\( W := W - \\alpha \\frac{1}{2m} \\, \\textstyle\\sum_{i=1}^m 2(W(x_i)-y_i)X_i \\)   \\( W := W - \\alpha \\frac{1}{m} \\, \\textstyle\\sum_{i=1}^m (W(x_i)-y_i)X_i \\)   \\( W := W - \\alpha \\frac{\\partial}{\\partial W} \\, cost(W) \\)      Derivative #  함수 f(x)에 대한 미분은 아래와 같음. x의 변화량이 0으로 수렴할때 y의 변화량을 의미.\n Derivative ...    \\( f\u0026#39;(x) = \\frac{\\Delta f(x)}{\\Delta x} = \\lim\\limits_{\\Delta x \\rightarrow 0 } \\, \\frac{f(x\u0026#43;\\Delta x)-f(x)}{\\Delta x} \\)      미분 기초 정리\n Derivative Basic ...    \\( f(x) = constant -\u0026gt; f\u0026#39;(x) = 0 \\)   \\( f\u0026#39;(x) = e ^ x =\u0026gt; f\u0026#39;(x) = e ^ x \\)   \\( f\u0026#39;(x) = e ^ -x =\u0026gt; f\u0026#39;(x) = -e ^ -x \\)   \\( f\u0026#39;(x) = ax ^ x =\u0026gt; f\u0026#39;(x) = nax ^ {n-1} \\)   \\( f\u0026#39;(x) = ln ^ x =\u0026gt; f\u0026#39;(x) = \\frac{1}{x} \\)   \\( \\frac{1}{x} = x^{-1} \\)      미분의 의미\n  Meaning of Derivative ...    \\( f(x) = x^2 \\)  일 경우  \\( f\u0026#39;(x) = 2 * x^ {2-1} = 2x \\)   \\( f(2) = 2^2 = 4 \\)  일 경우  \\( f\u0026#39;(2) = 2*2 = 4 \\)   \\( f(2) = 1^2 = 1 \\)  일 경우  \\( f\u0026#39;(2) = 2*1 = 2 \\)   \\( f(2) = 0^2 = 0 \\)  일 경우  \\( f\u0026#39;(2) = 2*0 = 0 \\)      즉 x = 2 일때 미분 f(x)는 4의 변화를 가지게 됨 즉 x = 1 일때 미분 f(x)는 2의 변화를 가지게 됨 즉 x = 0 일때 미분 f(x)는 0의 변화를 가지게 됨 즉 x의 한점에서 y의 변화량을 통해 위의 x^2이 Cost라 가정하고 반복한다면 기울기가 0이되는 즉 Cost가 최저인 점을 구할 수 있음.\n Practice 1 : Derivative ...    \\( f(x) = 3x^2 \u0026#43; e^x \u0026#43; 7 \\)  의  \\( f\u0026#39;(x) ? \\)   \\( = 3*2*x^{2-1} \u0026#43; e^x \u0026#43; 0 = 6x \u0026#43; e^x \\)       Practice 2 : Derivative ...    \\( f(x) = lnx \u0026#43; \\frac{1}{x} \\)  의  \\( f\u0026#39;(x) ? \\)    \\( = \\frac{1}{x} - \\frac{1}{x^2} \\)      입력변수가 하나 이상인 다변수 함수에서 사용하는 편미분을 사용. 편미분은 미분하고자 하는 변수를 제외하고 나머지는 상수로 취급.\n Practice 1 : Partial Derivative ...    \\( f(x,y) = 2x \u0026#43; 3xy \u0026#43; y^3 \\)  변수 x에 대해 편미분  \\( = \\frac{\\partial f(x,y)}{\\partial x} = \\frac{\\partial(2x\u0026#43;3xy\u0026#43;y^3)}{\\partial x} \\)   \\( = \\frac{\\partial 2x}{\\partial x} \u0026#43; \\frac{\\partial 3xy}{\\partial x} \u0026#43; \\frac{\\partial y^3}{\\partial x} \\)   \\( = 2 \u0026#43; 3y \u0026#43; 0 \\)   \\( = 2 \u0026#43; 3y \\)   \\( f(x,y) = 2x \u0026#43; 3xy \u0026#43; y^3 \\)  변수 y에 대해 편미분  \\( = \\frac{\\partial f(x,y)}{\\partial y} = \\frac{\\partial(2x\u0026#43;3xy\u0026#43;y^3)}{\\partial y} \\)   \\( = \\frac{\\partial 2x}{\\partial y} \u0026#43; \\frac{\\partial 3xy}{\\partial y} \u0026#43; \\frac{\\partial y^3}{\\partial y} \\)   \\( = 0 \u0026#43; 3x \u0026#43; 3y^2 \\)   \\( = 3x \u0026#43; 3y^2 \\)      복합 함수를 위해 Chain Rule을 통해 미분. 특정 함수를 치환하여 약분 개념을 적용. 두 함수 곱의 미분은 단순 곱이 아니며 Product Rule이 적용됨.\n  Chain rule ...    \\( \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial t} \\circ \\frac{\\partial t}{\\partial x} \\)       Product rule ...    \\( \\frac{\\partial}{\\partial x}[f(x)g(x)]=f(x)g\u0026#39;(x)\u0026#43;f\u0026#39;(x)g(x) \\)       Practice 1 : Chain Rule ...    \\( f(x) = e ^ {3x^2} \\space \\space \\space e^t , \\space t = 3x^2 \\)   \\( \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial t} \\circ \\frac{\\partial t}{\\partial x} = \\frac{\\partial (e^t)}{\\partial t} \\circ \\frac{\\partial (3x^2)}{\\partial x} = (e^t)(6x) = (e^{3x^2})(6x) = 6xe^{3x2} \\)       Practice 2 : Chain Rule ...    \\( f(x) = e^{-x} \\space \\space \\space e^t , \\space t = -x \\)   \\( \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial t} \\circ \\frac{\\partial t}{\\partial x} = \\frac{\\partial (e^t)}{\\partial t} \\circ \\frac{\\partial (-x)}{\\partial x} = (e^t)(-1) = (e^{-x})(-1) = -e^{-x} \\)       Practice 3 : Chain/Product Rule ...    \\( f(x) = 3xe^x \\)   \\( \\frac{\\partial}{\\partial x}(3xe^x) = 3 \\Big( \\frac{\\partial}{\\partial x}(e^x x) \\Big) \\)  Product Rule을 적용  \\( \\frac{\\partial}{\\partial x}(u v) = v \\frac{\\partial u}{\\partial x} \u0026#43; u \\frac{\\partial v}{\\partial x} \\)  다음으로 치환  \\( u = e^x \\space v = x \\)   \\( 3 \\Big( x \\frac{\\partial}{\\partial x}(e^x) \u0026#43; e^x \\frac {\\partial}{\\partial x}(x) \\Big) \\)  Chain Rule을 적용  \\( \\frac{\\partial}{\\partial x}(e^x) = \\frac {\\partial e^u}{\\partial u} \\frac{\\partial u}{\\partial x} \\)  다음으로 치환  \\( u = x, \\space \\frac{\\partial}{\\partial u}(e^u)=e^u \\)   \\( = 3 \\Big( x e^x \\frac{\\partial}{\\partial x}(x) \u0026#43; e^x \\frac{\\partial}{\\partial x}(x) \\Big) \\)   \\( = 3 \\Big( x e^x 1 \u0026#43; e^x \\frac{\\partial}{\\partial x}(x) \\Big) \\)   \\( = 3 \\Big( x e^x \u0026#43; e^x 1 \\Big) \\)   \\( = 3 ( x e^x \u0026#43; e^x ) \\)   \\( = 3 e^x( x \u0026#43; 1 ) \\)      Loss Function #  다시 선형회귀에서 실측되는 데이터와 f(x) = wx+b간 error는 최소가 되어야함. Error가 최소가 되는 W,B를 연속적으로 측정하기 위해 사용되는 것이 손실함수임.\n  Loss Function ...    \\( Loss Funtion = \\frac{(t_1-y_1)^2 \u0026#43; (t_2-y_2)^2 \u0026#43; ... \u0026#43; (t_n-y_n)^2}{n} \\)   \\( = \\frac{[t_1-(Wx_1\u0026#43;b)]^2 \u0026#43; [t_2-(Wx_2\u0026#43;b)]^2 \u0026#43; ... \u0026#43; [t_n-(Wx_n\u0026#43;b)]^2}{n} \\)   \\( = \\frac{1}{n} \\, \\displaystyle\\sum_{i=1}^n \\, [t_i-(Wx_i\u0026#43;b)]^2 \\)       원 기울기에서 학습률*미분만큼을 감소시키며 기울기가 0이 되는 최적해로 진행됨.\n Gradient Descent ...    \\( W := W - \\alpha \\frac{\\partial}{\\partial W} \\, \\frac{1}{2m} \\textstyle\\sum_{i=1}^m (W(x_i)-y_i)^2 \\)   \\( W := W - \\alpha \\frac{1}{2m} \\, \\textstyle\\sum_{i=1}^m 2(W(x_i)-y_i)X_i \\)   \\( W := W - \\alpha \\frac{1}{m} \\, \\textstyle\\sum_{i=1}^m (W(x_i)-y_i)X_i \\)   \\( W := W - \\alpha \\frac{\\partial}{\\partial W} \\, cost(W) \\)   \\( b := b - \\alpha \\frac{\\partial}{\\partial b} \\, cost(b) \\)      여기서 학습률은 최적해를 향한 진행 폭을 결정. 작을 경우 성능이 저하. 클 경우 학습이 진행되지 않음.\n  Learning Rate ...    \\( W = W - \\alpha \\, \\frac{\\partial E(W,b)}{\\partial W} \\)       이론적으로 Convex Function이라면 대체로 최적해를 잘 찾을 수 있으나 그렇지 않다면 Parameter에 따라 결과가 상이할 수 있음.\n Dot Product #  모든 요소들의 행렬곱을 통해 계산.\n  Dot Product ...    \\( x_1 * W \u0026#43; b_1 = y_1 \\)   \\( x_2 * W \u0026#43; b_2 = y_2 \\)   \\( x_3 * W \u0026#43; b_3 = y_3 \\)   \\( x_4 * W \u0026#43; b_4 = y_4 \\)   \\( x_5 * W \u0026#43; b_5 = y_5 \\)  행렬의 곱으로 전환  \\( \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ x_5 \\end{pmatrix} \\circ (W) \u0026#43; b = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ y_3 \\\\ y_4 \\\\ y_5 \\end{pmatrix} \\)   \\( X \\circ W \u0026#43; b = Y \\)       Multi Variable Dot Product ...    \\( \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\\\ x_5 \\end{pmatrix} \\circ \\begin{pmatrix} w_1 \\\\ w_2 \\\\ w_3 \\end{pmatrix} \u0026#43; b = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ y_3 \\\\ y_4 \\\\ y_5 \\end{pmatrix} \\)   \\( X \\circ W \u0026#43; b = Y \\)      Logistic Regression #  Regression을 통해 처리된 결과를 Classification 처리함. Linear Regression의 결과는 수치형 값을 가지게 됨으로 분류 문제에 취약. Linear한 결과를 Logistic Regression을 통해 선택의 결과로 대치.\n 분류의 문제를 위해 지수 함수  \\( e^x \\)  를  \\( e^{-x} \\)  로 전환 후  \\( \\frac{1}{1 \u0026#43; e^{-x}} \\)  에 대입하여 x의 좌측으로 진행할수로  \\( \\infty \\)  에 가까워지며 0에 수렴하게되고 x의 우측으로 진행하게 될수록 0에 수렴하면서 1에 가까워지는 결과가 됨.\n   Sigmoid ...    \\( Z = Wx \u0026#43; b \\)   \\( y = \\frac {1}{1\u0026#43;e^{-(Wx\u0026#43;b)}} \\)   \\( y = sigmoid(Z) = \\sigma (z) = \\frac{1}{1\u0026#43;e^{-z}} \\)      Logistic Regression의 Cost Function은 y = 1 일때와 y = 0 일때로 구분할 수 있는데 y = 1 일때는  \\( \\log(h(x)) \\)  의 역  \\( -\\log(h(x)) \\)  을 취해 0으로 근접할 수록 오차가  \\( \\infty \\)  에 수렴하게 됨. 반대로 y = 0 일때는  \\( \\log(1 - h(x)) \\)  와 같이 1에서 차감하여 1에 근접할 수록 오차가  \\( \\infty \\)  에 수렴하함. 이 두 식을 합하면 Logistic Regression의 Convex한 Cost Funtion이 되게 됨.\n  Cross-Entropy 유도의 또다른 설명은 다음과 같음.\n하나의 입력 x에 대해 출력이 1일 확률을 y로 정의. y는 0 또는 1일임으로 y = sigmoid(Wx+b)로 나타낼 수 있음. 입력 x에 대해 출력이 0일 확률은 1이 나타날 확률의 나머지임으로 1-y 임. 확률 변수 C는 0 또는 1 이외에는 존재하지 않음으로 베르누이 시행을 전제로 하며 베르누이 분포의 확률질량함수(PMF)는 아래와 같이 정의됨. 이를 Log 변환을 통해 Convex의 형태와 극점의 위치를 유지하며 곱을 선형의 조합 꼴로 풀 수 있도록 변환함.\n Bernoulli Distribution (PMF) ...    \\( p(C=1|x) = y = sigmoid(Wx\u0026#43;b) \\)   \\( p(C=0|x) = 1 - p(C=1|x) = 1 - y \\)   \\( p(C=p|x) = y^p ( 1 - y )^{1-P} \\)   \\( Likelyhood (W,b) = \\displaystyle\\prod_{i=1}^n p(C=p_i|x_i) = \\displaystyle\\prod_{i=1}^n y_i^{p_i} (1-y_i)^{1-p_i} \\)   \\( E(W,b) = - \\log L(W,b) = -\\displaystyle\\sum_{i=1}^n \\lbrace t_i \\textstyle\\log y_i \u0026#43; (1-p_i) \\log(1-y_i) \\rbrace \\)       Logistic Regression Cross Entropy ...    \\( y = \\frac{1}{1\u0026#43;e^{-(Wx\u0026#43;b)}} , \\space p_i = 0 \\space or \\space 1 \\)   \\( E(W,b) = - \\, \\displaystyle\\sum_{i=1}^n \\, \\lbrace p_i \\, \\log y_i \u0026#43; (1-p_i) \\log (1-y_i) \\rbrace \\)      Bayes Theorem #  Logit, Sigmoid, Softmax를 유도하기 위해 다음과 같은 확률의 개념이 선행되어야함.\n 베이지안 예제 몬티홀문제 베이즈의 정리  불확실성 하의 의사 결정의 문제를 수학적으로 다룰때 사용되는 베이즈의 정리(Bayes Theorem)와 전확률 법칙(law of total probability)는 다음과 같음.\n Bayes Theorem ...    \\( P(Y|X) = \\frac {P(X \\bigcap Y)}{P(X)} \\)   \\( P(X|Y) = \\frac {P(Y \\bigcap X)}{P(Y)} \\)   \\( P(Y \\bigcap X) = P(X \\bigcap Y) = P(X|Y)P(Y) = P(Y|X)P(X) \\)   \\( \\therefore P(Y|X) = \\frac {P(X|Y)P(Y)}{P(X)} \\)  P(Y|X) : 사후확률(Posterio probability)\nP(X|Y) : 가능도(likelihood)\nP(Y) : 확률변수 Y의 사전확률(prior probability)\nP(X) : 확률변수 X의 사전확률(prior probability)\n    표본 공간 S를 n개로 나누었을때 사건 A의 확률은 다음과 같이 나타나며 총합은 1이됨.\n Law of total probability ...    \\( P(A) = P(A \\bigcap B_1) \u0026#43; P(A \\bigcap B_2) \u0026#43; ... \u0026#43; P(A \\bigcap B_n) \\)      일반적으로  \\( A_1,A_2,A_3 \\)  가 서로 Mutually Exclusive이고 이들의 합집합이 표본공간과 S와 같으면 사건  \\( A_1,A_2,A_3 \\)  는 표본공간 S의 분할이라고 정의. 특정 사건 B가 나타날 확률은 전확률 공식에 의거 다음과 같이 표현할 수 있음.\n B : Law of total probability ...    \\( P(B)) = P(A_1)P(B|A_1)\u0026#43; P(A_2)P(B|A_2) \u0026#43; P(A_3)P(B|A_3) = \\displaystyle\\sum_{i=1}^3 P(A_i)P(B|A_i) \\)       \\(P(A_1)\\)  , \\(P(A_2)\\)  , \\(P(A_3)\\)  은 미리 알고 있다는 의미로 사전확률(Prior Probability)로 불리고,  \\(P(B|A_1)\\)  , \\(P(B|A_2)\\)  , \\(P(B|A_3)\\)  는 우도(Likelihood Probability)라 부름.\n \\( P(A_1|B) \\)  는 사건 B를 관측한 후 원인이 되는 사건 A의 확률을 따졌다는 의미에서 사후확률(Posterior Probability)로 정의되며 다음과 같이 나타낼 수 있음.\n Posterior Probability ...    \\( P(A_1|B)) = \\frac {P(A_1)P(B|A_1)}{P(B)} = \\frac {P(A_1)P(B|A_1)}{P(A_1)P(B|A_1)\u0026#43;P(A_2)P(B|A_2)\u0026#43;P(A_3)P(B|A_3)} \\)       Practice 1 : 진단문제 ...   전체 인구의 1%가 어떤 병에 걸렸다고 가정. 이 병의 진단 정확도가 97% 오진률은 6%라고 가정.\n \\( P(D) = 0.01 \\)  : 사전확률  \\( P( \\backsim D) = 0.99 \\)  : 사전확률  \\( P(\u0026#43;|D) = 0.97 \\)  : 우도  \\( P(\u0026#43;| \\backsim D) = 0.06 \\)  : 우도  \\( P(D|\u0026#43;) \\)  = ????? : 사후확률 (진단테스트 양성일때 실제 환자일 확률 )  \\( P(\u0026#43;) = P(D \\cap \u0026#43;)\u0026#43;P( \\backsim D \\cap \u0026#43;) \\)   \\( = P(D)P(\u0026#43;|D)\u0026#43;P( \\backsim D)P(\u0026#43;| \\backsim D) \\)   \\( = 0.01 \\times 0.97 \u0026#43; 0.99 \\times 0.06 \\)   \\( = 0.691 \\)   \\( P(D|\u0026#43;) = \\frac {P(D)P(\u0026#43;|D)}{P(\u0026#43;)} \\)   \\( = \\frac {0.01 \\times 0.97}{0.691} \\)   \\( = 0.014 \\)       Practice 2 : 딸기맛 문제 ...   사탕주머니 1 : 딸기맛 30개, 포도맛 10 사탕주머니 2 : 딸기맛 20개, 포도맛 20 두 주머니에서 임의로 골랐을때 딸기였다면 주머니1에서 나왔을 확률은?  \\( P(H) \\)  : 사전확률 - 주머니1을 고를 확률  \\( P(D|H) \\)  : 우도 - 주머니1의 딸기 확률  \\( P(D) \\)  : 한정상수 - 딸기를 고를 확률  \\( P(H|D)) \\)  : 사후확률 - 주머니1에서 딸기를 골랐을 확률  \\( P(H|D)) = \\frac {P(H)P(D|H)}{P(D)} = \\frac { \\frac {1}{2} * \\frac {3}{4} }{ \\frac {5}{8} } = \\frac {3}{5} \\)  이때 한정상수  \\( P(D) \\)  는 상호배제(Mutually Exclusive)와 전체포괄(Collectively Exhaustive)의 원칙에서 같은 값을 지니며 계산이 생략됨\n   Point Theory1 Theory2     사전확률 P(H) 1/2 1/2   우도P(D H) 3/4   사전확률*우도 3/8 1/4   한정상수P(D) 5/8 5/8   사후확률P(H D) 3/5     \\( P(H|D) = \\frac {P(H)P(D|H)}{P(D)} = \\frac { \\frac {1}{2} * \\frac {3}{4} }{ \\frac {5}{8} } = \\frac {3}{5} \\)       Practice 3 : 카드문제 ...   카드A : 앞뒤 모두 검은색\n카드B : 앞은 검은색, 뒤는 하얀색\n카드C : 앞뒤 모두 하얀색\n세카드 중 하나를 뽑아서 본면이 검은색일 때 그 뒷면도 검은색이 나올 확률\n \\( P(A|Black) = \\frac {P(A)P(Black|A)}{P(Black)} \\)   \\( = \\frac {P(A)P(Black|A)}{P(A)P(Black|A)\u0026#43;P(B)P(Black|B)} \\)   \\( = \\frac { \\frac {1}{3} * 1 }{ \\frac {1}{3} * 1 \u0026#43; \\frac{1}{3} * \\frac{1}{2} } = \\frac {2}{3} \\)       Practice 4 : 몬티홀문제 ...   문A1 : 상금\n문A2 : 꽝\n문A3 : 꽝\n출연자가 문을 하나 선택한 후\n사회자가 다른 문을 열어 문을 하나 보여준 후\n출연자가 선택을 바꾸지 않고 문을 열때의 당첨 확률\n \\( P(A1|B) = \\frac {P(A1 \\cap B))}{P(B)} = \\frac {P(A1 \\cap B)}{P(A1 \\cap B) \u0026#43; P(A2 \\cap B) \u0026#43; P(A3 \\cap B)} = \\frac { P(A1)P(B|A1) }{ P(A1)P(B|A1) \u0026#43; P(A2)P(A2|B) \u0026#43; P(A3)P(A3|B) } = \\frac {\\frac {2}{3} * \\frac {1}{2}}{\\frac {1}{3}* \\frac {1}{2} \u0026#43; \\frac {1}{3}*0 \\frac {1}{3}*1} = \\frac {1}{3} \\)      Logit / Sigmoid / Softmax #  Logit /Sigmoid /Softmax의 관계를 정리\n 참고1 gwkoo.log - Logit,Sigmoid,Softmax의 관계 참고2 한 페이지 머신러닝 Logit,Sigmoid,Softmax의 관계 참고3 ChaCha\u0026rsquo;s blog - Sigmoid, Logit and Softmax 참고4 ratsgo\u0026rsquo;s blog - 베이즈 규칙과 다양한 문제들  Logit은 Log Odds를 의미.\nOdds란 도박에서 얻을 확률과 잃을 확률의 비율을 의미\n Odds / Logit ...    \\( Classes : C_1, C_2 \\)   \\( Probability of C_1 given X : y = P(C_1|X) \\)   \\( Probability of C_2 given X : 1-y = P(C_2|X) \\)  Odds =  \\( \\frac {y}{1-y} = \\frac {P(C_1|X)}{1-P(C_1|X)} \\)  Choose =  \\( \\begin{cases} C_1 \\space if \\space \\frac {y}{1-y} \u0026gt; 1 \\\\ C_2 \\space if \\space \\frac {y}{1-y} \u0026lt; 1 \\end{cases} \\)      이를 Log를 이용해 0~1의 범위로 한정된 Logit을 도출\n Logits ...    \\( = log \\Big( \\frac{y}{1-y} \\Big) \\)   \\( = log \\Big( \\frac{P(C_1|X)}{1-P(C_1|X)} \\Big) \\)   \\( z = log( \\frac {y}{1-y} \\)  ,  \\( e^z = ( \\frac {y}{1-y} ) \\)   \\( e^z = ( \\frac {y}{1-y} ) \\)   \\( \\frac {1}{e^z} = \\frac {1-y}{y} \\)  =  \\( \\frac {1}{e^z} = \\frac {1}{y} -1 \\)   \\( \\frac {1}{e^z} \u0026#43; 1 = \\frac {1}{y} \\)  =  \\( \\frac {1 \u0026#43; e^z}{e^z} = \\frac {1}{y} \\)   \\( \\frac {e^z}{1 \u0026#43; e^z} = y \\)   \\( \\frac {e^z / e^z}{(1 \u0026#43; e^z)/e^z} = y \\)   \\( \\frac {1}{ \\frac{1}{e^z} \u0026#43; 1 } = y \\)   \\( \\frac {1}{ e^{-z} \u0026#43; 1 } = y \\)   \\( \\therefore y = \\frac {1}{ 1 \u0026#43; e^{-z}} \\)      여기서 Softmax는 Sigmoid를 K개 이상으로 일반화 하여 유도.\n Softmax ...    \\( \\frac {P(C_1|X)}{P(C_2|X)} = e^z \\)   \\( \\frac {P(C_i|X)}{P(C_k|X)} = e^{z_i} \\)   \\( \\displaystyle\\sum_{i=1}^{k-1} \\frac { P(C_i|X)}{P(C_k|X)} = \\displaystyle\\sum_{i=1}^{k-1} e^{z_i} \\)   \\( \\frac {P(C_1|X)\u0026#43;P(C_2|X)\u0026#43;...\u0026#43;P(C_{k-1}|X)}{P(C_k|X)} = \\displaystyle\\sum_{i=1}^{k-1} e^{z_i} \\)   \\( \\frac {1-P(C_k|X)}{P(C_k|X)} = \\displaystyle\\sum_{i=1}^{k-1} e^{z_i} \\)   \\( P(C_k|X) = \\frac{1}{1\u0026#43; \\textstyle\\sum_{i=1}^{k-1} e^{z_i} } \\)   \\( P(C_i|X) = e^{z_i} P(C_k|X) \\)   \\( P(C_i|X) = \\frac {e^{z_i}}{1 \u0026#43; \\textstyle\\sum_{i=1}^{k-1} e^{z_i}} \\)   \\( P(C_i|X) = \\frac {e^{z_i}}{e^{z_i} \u0026#43; \\textstyle\\sum_{i=1}^{k-1} e^{z_i}} = \\frac {e^{z_i}}{ \\textstyle\\sum_{i=1}^{k} e^{z_i}} \\)        OpenTutorial \u0026#x21a9;\u0026#xfe0e;\n \u0026ldquo;Regression toward the mean\u0026rdquo;, Sir Francis Galton (1822~1911) \u0026#x21a9;\u0026#xfe0e;\n Global 해를 찾는 과정 \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':19,'href':'/docs/documents/deeplearning/tensorflow/','title':"Tensorflow",'section':"Deep Learning",'content':"Tensor Flow #   텐저 플로우는 2015년 구글에서 공개한 머신러닝 라이브러리. 케라스는 딥러닝 라이브러리를 Backend로 하는 신경망 모델 구성 라이브러리. 구글은 쥬피터 노트북이라는 오픈 소스 웹 어플리케이션을 코랩이라는 서비스를 통해 제공하고 있음.\nTensor Flow Keras Python Jupyter Notebook Colab\n이때 Tensor는 흘러다니는 데이터를 의미함.\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph LR A((X:Tensor))--|Edge|C((+:Node))--|Edge|D((X+Y:Tensor)) B((Y:Tensor))--|Edge|C style A fill:#ffffff,stroke:#000000,stroke-width:1px style B fill:#ffffff,stroke:#000000,stroke-width:1px style C fill:#ffffff,stroke:#000000,stroke-width:1px style D fill:#ffffff,stroke:#000000,stroke-width:1px 작성중\n"});index.add({'id':20,'href':'/docs/documents/business/','title':"Business",'section':"Documents",'content':"Business #     Supply Chain Management   Description   "});index.add({'id':21,'href':'/docs/documents/english/','title':"English",'section':"Documents",'content':"English #     Picked Up English   Picked up english expressions here and there from web sites   Seulsam   English Expression from SeulSam   "});index.add({'id':22,'href':'/docs/documents/english/pickedup/','title':"Picked Up English",'section':"English",'content':"English Expression Diary #   A little bird told me #  동문서답으로 \u0026lsquo;그냥 주워들었어\u0026rsquo; 표현. \u0026lsquo;Tell me. Where did you hear that?\u0026rsquo; \u0026lsquo;A little bird told me.\u0026rsquo;\nBigger fish to fry #  \u0026lsquo;좀 더 중요하고 큰 다른 것\u0026rsquo;이란 의미. \u0026lsquo;Why did you turn down their offer?\u0026rsquo; \u0026lsquo;Oh, I have bigger fish to fry.\u0026rsquo;\nCan of Worms #  \u0026lsquo;심각한 문제를 초래할 수 있는 위험\u0026rsquo;. \u0026lsquo;What do you think about the new tax law?\u0026rsquo; \u0026lsquo;I think it\u0026rsquo;s opening a can of worms.\u0026rsquo;\nCuriousity kills the cat #  \u0026lsquo;괜한 호기심이 화를 부른다\u0026rsquo;라는 표현. \u0026lsquo;I want to know who\u0026rsquo;s behind the plot.\u0026rsquo; \u0026lsquo;Curiosity kills the cat. Keep that in mind.\u0026rsquo;\nStop and kick every dog that barks at you #  \u0026lsquo;조금이라도 타인이 듣기 싫은 소리하는걸 못참아 하는 것\u0026rsquo;을 의미. \u0026lsquo;Don\u0026rsquo;t stop and kick every dog that barks at you. You are wasting your time\u0026rsquo; \u0026lsquo;I know. I know. But sometimes it really gets on my nerves.\u0026rsquo;\nTry telling me English is easy. #  \u0026lsquo;Try me\u0026rsquo;는 \u0026lsquo;How you dare\u0026rsquo;의 뜻 \u0026ldquo;어디 한번 영어가 쉽다고 말해보시지?\u0026rdquo; 정도.\nEase into #  천천히 들듯이 적응하다는 의미.\nFeel insecure about someone\u0026rsquo;s appearance #  외모에 자신감이 없다는 뜻.\nElbow me in the rib #  옆구리를 쿡쿡 찌른다는 의미.\nBe good at #  ~ 잘하다. \u0026ldquo;I\u0026rsquo;m not good at English.\u0026rdquo;\nStay safe #  항상 조심해. Be Safe. 조심해. 잘지내. 정도.\nI don\u0026rsquo;t want your help to go in vain. #  \u0026ldquo;괜한짓 하지 않으셔도 되요\u0026rdquo; 정도.\nThe mortifying ordeal of being known. #  \u0026ldquo;알려졌다는 수치스러운 그 고통\u0026rdquo;.\nThat\u0026rsquo;s so cheesy! #  오글거린다는 표현\nHe is so lucky his face does it for him when he has an attitude. #  \u0026ldquo;약간 거들먹 거려도 그의 얼굴이 받쳐주니 참 행운아네\u0026rdquo; 정도.\nWhy would you do that?! #  \u0026ldquo;왜 그럴려고 하는데?\u0026ldquo;와 \u0026ldquo;왜 그랬니\u0026rdquo; 정도.\nGod complex #  신 컴플렉스이네요. 자신이 신 또는 메시아라고 믿는 과대망상.\nShe is so catch. #  튕긴다는 표현.\nThe ramen will get mushy and soggy. #  \u0026ldquo;라면 불겠다\u0026quot;는 표현.\nMirror selfie #  전신을 거울로 찍는 셀카.\nShowing off #  생색낸다는 표현.\nBe possessed by a ghost #  귀신들렸다는 표현.\nhigh-maintenance #  손이 많이 간다는 표현.\nI\u0026rsquo;m practicing passive listening while I study the bible. #  성경을 공부하며 흘려듣기로 듣기 연습을 한다.\nKeep your eyes peeled for my message coming soon. #  내가 답장할때까지 눈 똑바로 뜨고 잘보고 있어.\nCheeky #  아주 밉지 않은 얄미운것.\nBath dipper or pail #  손잡이 달린 바가지.\nKeep your bangs #  앞머리 자르지 마\nFolded the paper star #  종이별 접는다\nSpirit animal #  대표 영혼? 롤모델?\nTo call on #  선생님들이 학생들한테 질문을 묻기 위해 부름\nHis research put forth 5 hypotheses. #  그의 연구는 다섯가지의 가설을 제시한다.\nWhat are some cheesy pick-up lines in English? #  영어로 오글거리는 작업멘트 알려주세요.\nSo the most I will do is send a message #  답글 보내는거 이상은 하지 않겠다.\nPiggyback ride #  어부바\nTo knead rice #  쌀을 빚다\nThe power of someone\u0026rsquo;s glasses #  안경 도수\nWhat\u0026rsquo;s with you #  너 왜그러니?\n‎A smile curves up his lips #  그의 입가에 미소가 번졌다.\nThis cleanser is a splurge #  이 클린저는 돈낭비입니다.\nBullshitting #  지랄\nAbbreation Form in messanger #  TY : Thank you\nYW : You\u0026rsquo;re welcome\nTTYL : Talk to you later.\nK : Okay.\nSUP : Wat\u0026rsquo;s UP?\nIK : I know.\nDon\u0026rsquo;t tread on me #  Gadsden flag\nAn unearned win / the game by default #  부전승\nLike I used to #  예전 같은\nFor the life of me #  아무리 생각해봐도\u0026rdquo; I can\u0026rsquo;t remember her name for the life of me.\nShoot the breeze #  수다를 떤다\nShoot one\u0026rsquo;s mouth off #  주절거린다\nI\u0026rsquo;m good #  난 됐어\nDownward spiral #  악순환\nGwak, Blank expression #  Gwaking은 멍한, 얼빠진 표정\nCome over to my place #  우리 집에 놀러와\nOne of the three dog days #  복날\nMaintain composure #  평정심 유지\n"});index.add({'id':23,'href':'/docs/documents/english/seulsam/','title':"Seulsam",'section':"English",'content':"English Expression Diary - 구슬쌤 자신감 팍팍 영어 #   구슬쌤의 자신감 팍팍 영어를 정리\nI find it doable #  할만해\nI find it challenging #  힘들긴하지만 해볼만해\nDid you eat at all? #  뭐 좀 먹었니?\nIf you need anthing at all, please let me know. #  뭐라도 필요하시면 알려주세요. (T..T 표현 감동입니다.)\nI\u0026rsquo;m in the middle of a metting. Can I send back in just a minute? #  한참 회의 중인데 좀있다 보내되 될까?\nI\u0026rsquo;m at work. #  난 근무중이야.\nYou mad my day. #  덕분에 기분 좋아.\nYou don\u0026rsquo;t appreciate good man. #  좋은 남자의 진가를 몰라보내.\nI appreciate it. Of course #  네 덕분이야. 천만에요. (?)\nThank you. No, thank YOU. #  고마워요. 천만에요.\nHow old do you think she is? I think.. she\u0026rsquo;s 30-ish. #  그 여자가 몇살인거 같니. 내 생각엔 대략 30살정도?\n"});index.add({'id':24,'href':'/docs/documents/gamedev/','title':"Game Dev",'section':"Documents",'content':"Game Dev #     C   Description   C\u0026#43;\u0026#43;   Description   "});index.add({'id':25,'href':'/posts/201022/','title':"Personal Log",'section':"Blog",'content':" 전체 기록 초기화 진행. 전체 어조 변경 진행. 당 사이트는 개인 기록 용도로 전환. 블로그에서 일자가 과거일 경우 조회가 되지 않는 내용 확인. 블로그 요약 표시는 전반 400자 정도를 추출하여 표시. BOOK 테마 원본 수정 조치 (Summary -\u0026gt; Description 전환)\n 다음글  "});index.add({'id':26,'href':'/posts/200928/','title':"Hello World!",'section':"Blog",'content':" Software Programing Language한 지금까지 다루어 언어는 총 21개 항목. ASP.NET, BASIC, C, C#, C++, Coldfusion, Command Script, CSS, Go, HTML, Java, Javascript, PHP, ProC, Python3, PL/SQL, Rust, SQL, Unix Shell, VBScript. 직무 관련 언어 몇가지를 제외하면 모두를 자유롭게 다루지는 못함. 최근 관심언어는 Rust,Go,Javascript,Python,Web Assembly 등이 있음. 전체적으로는 범용성이 높은 언어를 깊게 가져가기를 희망하나 목표가 불분명해 언어사이를 방황하고 있는 듯한 소견임. 하기 컬렉션 사이트를 참조하여 \u0026lsquo;Hello World\u0026rsquo; 생성 코드 작성하였음.\nhelloworldcollection\nASP.NET #  \u0026lt;%= \u0026#34;Hello World!\u0026#34; %\u0026gt;  언제 : 밀레니엄 즈음\u0026hellip;\n이유 : 개인 홈페이지 제작\u0026hellip;\n BASIC #  10 PRINT \u0026#34;Hello World!\u0026#34;  언제 : 중학교\u0026hellip; 이유 : 텍스트 기반 게임 제작\u0026hellip;\n C (Windows) #  #include \u0026lt;windows.h\u0026gt; int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR CmdLine, int Show) { MessageBox(GetActiveWindw(), \u0026#34;Hello World!\u0026#34;, \u0026#34;Hello Windows\u0026#34;, MB_OK); return 0; }  언제 : 대학교\u0026hellip; 이유 : 윈도우 API 공부\u0026hellip;\n C# #  class HelloWorld { static void Main() { System.Console.WriteLine(\u0026#34;Hello, World!\u0026#34;); } }  언제 : 2009년 5월\u0026hellip;\n이유 : 모델링 툴 제작\u0026hellip;\n C++ (.NET) #  using namespace System; void main() { console::WriteLine(\u0026#34;Hello World!\u0026#34;); }  언제 : 2003년 11월\u0026hellip;\n이유 : 이소메트릭 게임 제작\u0026hellip;\n ColdFusion #  \u0026lt;cfset message = \u0026#34;Hello World!\u0026#34;\u0026gt; \u0026lt;cfoutput\u0026gt; #message# \u0026lt;/cfoutput\u0026gt;  언제 : 석사\u0026hellip;\n이유 : 과제\u0026hellip;\n CommandScript #  echo \u0026#34;Hello World!\u0026#34;  언제 : 가끔\u0026hellip;\n이유 : 파일정리\u0026hellip;\n CSS #  body:before { content: \u0026#34;Hello World!\u0026#34;; }  언제 : 최근\u0026hellip;\n이유 : Frontend 공부\u0026hellip;\n Go #  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello Wrold!\u0026#34;) }  언제 : 최근\u0026hellip;\n이유 : Backend 공부\u0026hellip;\n HTML #  \u0026lt;HTML\u0026gt; \u0026lt;HEAD\u0026gt; \u0026lt;TITLE\u0026gt;Hello World!\u0026lt;TITLE\u0026gt; \u0026lt;/HEAD\u0026gt; \u0026lt;BODY\u0026gt; \u0026lt;H1\u0026gt;Hello World!\u0026lt;/H1\u0026gt; \u0026lt;/BODY\u0026gt; \u0026lt;/HTML\u0026gt;  언제 : 최근\u0026hellip;\n이유 : Frontend 공부\u0026hellip;\n Java #  class HelloWorld { static public void main (String args[]) { System.out.println(\u0026#34;Hello World!\u0026#34;); } }  언제 : 대학교\u0026hellip; 이유 : 학부수업\u0026hellip;\n JavaScript #  console.log(\u0026#34;Hello World!\u0026#34;)  언제 : 최근\u0026hellip;\n이유 : Frontend 공부\u0026hellip;\n PHP #  \u0026lt;?php echo \u0026#39;Hello World!\u0026#39;; ?\u0026gt; 언제 : 대학교\u0026hellip; 이유 : 개인 홈페이지 제작\u0026hellip;\n ProC #  #include \u0026lt;stdio.h\u0026gt;EXEC SQL INCLUDE SQLCA; int main() { char hello[15]; char *user = \u0026#34;user\u0026#34;; char *pass = \u0026#34;password\u0026#34;; char *sid = \u0026#34;the_sid\u0026#34;; EXEC SQL CONNECT :user IDENTIFIED BY :password USING :sid; EXEC SQL SELECT \u0026#39;Hello World!\u0026#34; INTO :hello FROM DUAL; printf(\u0026#34;%s\\n\u0026#34;,hello) EXEC SQL COMMIT RELEASE; return 0; }  언제 : 2005년부터 2010년까지\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n Python3 #  print(\u0026#34;Hello World!\u0026#34;)  언제 : 최근\u0026hellip;\n이유 : 딥러닝 공부\u0026hellip;\n PL/SQL (Oracle) #  begin dbms_output.enable(1000); dbms_output.put_line(\u0026#39;Hello World!\u0026#39;); end;  언제 : 2005년 이후\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n Rust #  fn main () { println!(\u0026#34;Hello World!\u0026#34;); }  언제 : 최근\u0026hellip;\n이유 : Backend 공부\u0026hellip;\n SQL (Oracle) #  select \u0026#39;Hello World\u0026#39; from dual;  언제 : 2005년 이후\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n Unix Shell #  echo Hello World  언제 : 2005년부터 2010년까지\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n VBScript #  MsgBox \u0026#34;Hello world!\u0026#34;  언제 : 2010년부터 2017년까지\u0026hellip;\n이유 : 회사 업무\u0026hellip;\n  다음글  "});})();